/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <runtime/base/hphp_system.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>


using namespace std;

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////


// Class Invoke Tables
extern struct ObjectStaticCallbacks cw_reflectionfunctionabstract;
extern struct ObjectStaticCallbacks cw_reflectionobject;
extern struct ObjectStaticCallbacks cw_splfileobject;
extern struct ObjectStaticCallbacks cw_unexpectedvalueexception;
extern struct ObjectStaticCallbacks cw_stdclass;
extern struct ObjectStaticCallbacks cw_reflectionexception;
extern struct ObjectStaticCallbacks cw_overflowexception;
extern struct ObjectStaticCallbacks cw_splfileinfo;
extern struct ObjectStaticCallbacks cw_arrayiterator;
extern struct ObjectStaticCallbacks cw_appenditerator;
extern struct ObjectStaticCallbacks cw_outofboundsexception;
extern struct ObjectStaticCallbacks cw_logicexception;
extern struct ObjectStaticCallbacks cw_rangeexception;
extern struct ObjectStaticCallbacks cw_splobjectstorage;
extern struct ObjectStaticCallbacks cw_invalidargumentexception;
extern struct ObjectStaticCallbacks cw_reflectionclass;
extern struct ObjectStaticCallbacks cw_underflowexception;
extern struct ObjectStaticCallbacks cw_reflectionextension;
extern struct ObjectStaticCallbacks cw_outofrangeexception;
extern struct ObjectStaticCallbacks cw_reflectionmethod;
extern struct ObjectStaticCallbacks cw_badmethodcallexception;
extern struct ObjectStaticCallbacks cw_pear_error;
extern struct ObjectStaticCallbacks cw_reflectionproperty;
extern struct ObjectStaticCallbacks cw___php_incomplete_class;
extern struct ObjectStaticCallbacks cw_runtimeexception;
extern struct ObjectStaticCallbacks cw_exception;
extern struct ObjectStaticCallbacks cw_reflectionfunction;
extern struct ObjectStaticCallbacks cw_errorexception;
extern struct ObjectStaticCallbacks cw_recursivedirectoryiterator;
extern struct ObjectStaticCallbacks cw_directoryiterator;
extern struct ObjectStaticCallbacks cw_badfunctioncallexception;
extern struct ObjectStaticCallbacks cw_lengthexception;
extern struct ObjectStaticCallbacks cw_domainexception;
extern struct ObjectStaticCallbacks cw_recursiveiteratoriterator;
extern struct ObjectStaticCallbacks cw_directory;
extern struct ObjectStaticCallbacks cw_filteriterator;
extern struct ObjectStaticCallbacks cw_reflectionparameter;
Object co_pdoexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_pdoexception)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdoexception
Variant c_pdoexception::os_getInit(const char *s, int64 hash) {
  return c_exception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdoexception
Variant c_pdoexception::os_get(const char *s, int64 hash) {
  return c_exception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdoexception
Variant &c_pdoexception::os_lval(const char *s, int64 hash) {
  return c_exception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_pdoexception
void c_pdoexception::o_get(Array &props) const {
  c_exception::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_pdoexception
Variant c_pdoexception::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_pdoexception::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdoexception
Variant c_pdoexception::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_exception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdoexception
Variant c_pdoexception::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_pdoexception
bool c_pdoexception::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_pdoexception::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdoexception
bool c_pdoexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_exception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdoexception
bool c_pdoexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_pdoexception
Variant c_pdoexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_pdoexception::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdoexception
Variant c_pdoexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_exception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdoexception
Variant c_pdoexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_pdoexception
Variant& c_pdoexception::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_pdoexception::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdoexception
Variant& c_pdoexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_exception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdoexception
Variant& c_pdoexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_pdoexception
Variant c_pdoexception::os_constant(const char *s) {
  return c_exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_pdoexception
IMPLEMENT_CLASS(pdoexception)
c_pdoexception *c_pdoexception::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_pdoexception::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_pdoexception::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_pdoexception::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_pdoexception::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_pdoexception::cloneImpl() {
  c_pdoexception *obj = NEW(c_pdoexception)();
  cloneSet(obj);
  return obj;
}
void c_pdoexception::cloneSet(c_pdoexception *clone) {
  c_exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdoexception
Variant c_pdoexception::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdoexception
Variant c_pdoexception::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdoexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdoexception
Variant c_pdoexception::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdoexception
Variant c_pdoexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_pdoexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_pdoexception = {
  c_pdoexception::os_getInit,
  c_pdoexception::os_get,
  c_pdoexception::os_lval,
  c_pdoexception::os_invoke,
  c_pdoexception::os_constant,
};
Object co_domdocumentfragment(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domdocumentfragment)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocumentfragment
Variant c_domdocumentfragment::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocumentfragment
Variant c_domdocumentfragment::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocumentfragment
Variant &c_domdocumentfragment::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocumentfragment
void c_domdocumentfragment::o_get(Array &props) const {
  c_domnode::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_get_domdocumentfragment
Variant c_domdocumentfragment::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domdocumentfragment::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocumentfragment
Variant c_domdocumentfragment::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocumentfragment
Variant c_domdocumentfragment::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domdocumentfragment
bool c_domdocumentfragment::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domdocumentfragment::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocumentfragment
bool c_domdocumentfragment::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocumentfragment
bool c_domdocumentfragment::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_set_domdocumentfragment
Variant c_domdocumentfragment::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domdocumentfragment::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocumentfragment
Variant c_domdocumentfragment::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocumentfragment
Variant c_domdocumentfragment::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domdocumentfragment
Variant& c_domdocumentfragment::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domdocumentfragment::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocumentfragment
Variant& c_domdocumentfragment::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocumentfragment
Variant& c_domdocumentfragment::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocumentfragment
Variant c_domdocumentfragment::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocumentfragment
IMPLEMENT_CLASS(domdocumentfragment)
c_domdocumentfragment *c_domdocumentfragment::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domdocumentfragment::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domdocumentfragment::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domdocumentfragment::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domdocumentfragment::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domdocumentfragment::cloneImpl() {
  c_domdocumentfragment *obj = NEW(c_domdocumentfragment)();
  cloneSet(obj);
  return obj;
}
void c_domdocumentfragment::cloneSet(c_domdocumentfragment *clone) {
  c_domnode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumentfragment
Variant c_domdocumentfragment::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD(0x1E44C8E8C1920931LL, appendxml) {
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        return (t_appendxml(params[0]));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumentfragment
Variant c_domdocumentfragment::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD(0x1E44C8E8C1920931LL, appendxml) {
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        return (t_appendxml(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumentfragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocumentfragment
Variant c_domdocumentfragment::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocumentfragment
Variant c_domdocumentfragment::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      HASH_GUARD(0x1E44C8E8C1920931LL, appendxml) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendxml(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domdocumentfragment::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domdocumentfragment = {
  c_domdocumentfragment::os_getInit,
  c_domdocumentfragment::os_get,
  c_domdocumentfragment::os_lval,
  c_domdocumentfragment::os_invoke,
  c_domdocumentfragment::os_constant,
};
Object co_domtext(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domtext)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domtext
Variant c_domtext::os_getInit(const char *s, int64 hash) {
  return c_domcharacterdata::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domtext
Variant c_domtext::os_get(const char *s, int64 hash) {
  return c_domcharacterdata::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domtext
Variant &c_domtext::os_lval(const char *s, int64 hash) {
  return c_domcharacterdata::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domtext
void c_domtext::o_get(Array &props) const {
  c_domcharacterdata::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_get_domtext
Variant c_domtext::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domtext::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domtext
Variant c_domtext::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_domcharacterdata::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domtext
Variant c_domtext::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domtext
bool c_domtext::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domtext::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domtext
bool c_domtext::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domcharacterdata::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domtext
bool c_domtext::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_set_domtext
Variant c_domtext::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domtext::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domtext
Variant c_domtext::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_domcharacterdata::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domtext
Variant c_domtext::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domtext
Variant& c_domtext::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domtext::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domtext
Variant& c_domtext::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domcharacterdata::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domtext
Variant& c_domtext::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domtext
Variant c_domtext::os_constant(const char *s) {
  return c_domcharacterdata::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domtext
IMPLEMENT_CLASS(domtext)
c_domtext *c_domtext::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domtext::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    if (count <= 0) (t___construct());
    else (t___construct(params[0]));
  }
  return this;
}
void c_domtext::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  if (count <= 0) (t___construct());
  else (t___construct(params[0]));
}
void c_domtext::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
void c_domtext::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domtext::cloneImpl() {
  c_domtext *obj = NEW(c_domtext)();
  cloneSet(obj);
  return obj;
}
void c_domtext::cloneSet(c_domtext *clone) {
  c_domcharacterdata::cloneSet(clone);
}
Variant c_domtext::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domtext
Variant c_domtext::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(params[0], params[1]));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      HASH_GUARD(0x28FBAB4F0F6C02DDLL, iswhitespaceinelementcontent) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(params[0]), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(params[0], params[1]));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(params[0], params[1], params[2]));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 55:
      HASH_GUARD(0x714D38308D8212B7LL, splittext) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(params[0]));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(params[0], params[1]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domtext
Variant c_domtext::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      HASH_GUARD(0x28FBAB4F0F6C02DDLL, iswhitespaceinelementcontent) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD(0x714D38308D8212B7LL, splittext) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domtext
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domtext
Variant c_domtext::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domtext
Variant c_domtext::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      HASH_GUARD(0x28FBAB4F0F6C02DDLL, iswhitespaceinelementcontent) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD(0x714D38308D8212B7LL, splittext) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_domcharacterdata::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domtext::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domcharacterdata::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domtext = {
  c_domtext::os_getInit,
  c_domtext::os_get,
  c_domtext::os_lval,
  c_domtext::os_invoke,
  c_domtext::os_constant,
};
Object co_domcdatasection(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domcdatasection)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcdatasection
Variant c_domcdatasection::os_getInit(const char *s, int64 hash) {
  return c_domtext::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcdatasection
Variant c_domcdatasection::os_get(const char *s, int64 hash) {
  return c_domtext::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcdatasection
Variant &c_domcdatasection::os_lval(const char *s, int64 hash) {
  return c_domtext::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domcdatasection
void c_domcdatasection::o_get(Array &props) const {
  c_domtext::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_get_domcdatasection
Variant c_domcdatasection::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domcdatasection::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcdatasection
Variant c_domcdatasection::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_domtext::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcdatasection
Variant c_domcdatasection::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domcdatasection
bool c_domcdatasection::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domcdatasection::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcdatasection
bool c_domcdatasection::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domtext::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcdatasection
bool c_domcdatasection::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_set_domcdatasection
Variant c_domcdatasection::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domcdatasection::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcdatasection
Variant c_domcdatasection::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_domtext::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcdatasection
Variant c_domcdatasection::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domcdatasection
Variant& c_domcdatasection::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domcdatasection::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcdatasection
Variant& c_domcdatasection::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domtext::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcdatasection
Variant& c_domcdatasection::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domcdatasection
Variant c_domcdatasection::os_constant(const char *s) {
  return c_domtext::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domcdatasection
IMPLEMENT_CLASS(domcdatasection)
c_domcdatasection *c_domcdatasection::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domcdatasection::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    (t___construct(params[0]));
  }
  return this;
}
void c_domcdatasection::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  (t___construct(params[0]));
}
void c_domcdatasection::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_domcdatasection::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domcdatasection::cloneImpl() {
  c_domcdatasection *obj = NEW(c_domcdatasection)();
  cloneSet(obj);
  return obj;
}
void c_domcdatasection::cloneSet(c_domcdatasection *clone) {
  c_domtext::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcdatasection
Variant c_domcdatasection::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(params[0], params[1]));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      HASH_GUARD(0x28FBAB4F0F6C02DDLL, iswhitespaceinelementcontent) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(params[0]), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(params[0], params[1]));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(params[0], params[1], params[2]));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 55:
      HASH_GUARD(0x714D38308D8212B7LL, splittext) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(params[0]));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(params[0], params[1]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcdatasection
Variant c_domcdatasection::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      HASH_GUARD(0x28FBAB4F0F6C02DDLL, iswhitespaceinelementcontent) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD(0x714D38308D8212B7LL, splittext) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcdatasection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcdatasection
Variant c_domcdatasection::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcdatasection
Variant c_domcdatasection::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      HASH_GUARD(0x28FBAB4F0F6C02DDLL, iswhitespaceinelementcontent) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD(0x714D38308D8212B7LL, splittext) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_domtext::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domcdatasection::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domtext::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domcdatasection = {
  c_domcdatasection::os_getInit,
  c_domcdatasection::os_get,
  c_domcdatasection::os_lval,
  c_domcdatasection::os_invoke,
  c_domcdatasection::os_constant,
};
Object co_domdocumenttype(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domdocumenttype)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocumenttype
Variant c_domdocumenttype::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocumenttype
Variant c_domdocumenttype::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocumenttype
Variant &c_domdocumenttype::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocumenttype
void c_domdocumenttype::o_get(Array &props) const {
  c_domnode::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_get_domdocumenttype
Variant c_domdocumenttype::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domdocumenttype::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocumenttype
Variant c_domdocumenttype::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocumenttype
Variant c_domdocumenttype::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domdocumenttype
bool c_domdocumenttype::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domdocumenttype::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocumenttype
bool c_domdocumenttype::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocumenttype
bool c_domdocumenttype::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_set_domdocumenttype
Variant c_domdocumenttype::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domdocumenttype::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocumenttype
Variant c_domdocumenttype::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocumenttype
Variant c_domdocumenttype::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domdocumenttype
Variant& c_domdocumenttype::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domdocumenttype::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocumenttype
Variant& c_domdocumenttype::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocumenttype
Variant& c_domdocumenttype::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocumenttype
Variant c_domdocumenttype::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocumenttype
IMPLEMENT_CLASS(domdocumenttype)
c_domdocumenttype *c_domdocumenttype::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domdocumenttype::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domdocumenttype::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domdocumenttype::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domdocumenttype::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domdocumenttype::cloneImpl() {
  c_domdocumenttype *obj = NEW(c_domdocumenttype)();
  cloneSet(obj);
  return obj;
}
void c_domdocumenttype::cloneSet(c_domdocumenttype *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domdocumenttype::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumenttype
Variant c_domdocumenttype::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumenttype
Variant c_domdocumenttype::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocumenttype
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocumenttype
Variant c_domdocumenttype::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocumenttype
Variant c_domdocumenttype::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domdocumenttype::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domdocumenttype = {
  c_domdocumenttype::os_getInit,
  c_domdocumenttype::os_get,
  c_domdocumenttype::os_lval,
  c_domdocumenttype::os_invoke,
  c_domdocumenttype::os_constant,
};
Object co_sqlite3stmt(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_sqlite3stmt)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3stmt
Variant c_sqlite3stmt::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3stmt
Variant c_sqlite3stmt::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3stmt
Variant &c_sqlite3stmt::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3stmt
void c_sqlite3stmt::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_get_sqlite3stmt
Variant c_sqlite3stmt::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_sqlite3stmt::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3stmt
Variant c_sqlite3stmt::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3stmt
Variant c_sqlite3stmt::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_exists_sqlite3stmt
bool c_sqlite3stmt::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_sqlite3stmt::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3stmt
bool c_sqlite3stmt::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3stmt
bool c_sqlite3stmt::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_set_sqlite3stmt
Variant c_sqlite3stmt::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_sqlite3stmt::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3stmt
Variant c_sqlite3stmt::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3stmt
Variant c_sqlite3stmt::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_lval_sqlite3stmt
Variant& c_sqlite3stmt::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_sqlite3stmt::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3stmt
Variant& c_sqlite3stmt::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3stmt
Variant& c_sqlite3stmt::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3stmt
Variant c_sqlite3stmt::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3stmt
IMPLEMENT_CLASS(sqlite3stmt)
c_sqlite3stmt *c_sqlite3stmt::create(Object a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_sqlite3stmt::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
    (t___construct(params[0], params[1]));
  }
  return this;
}
void c_sqlite3stmt::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
  (t___construct(params[0], params[1]));
}
void c_sqlite3stmt::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
void c_sqlite3stmt::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_sqlite3stmt::cloneImpl() {
  c_sqlite3stmt *obj = NEW(c_sqlite3stmt)();
  cloneSet(obj);
  return obj;
}
void c_sqlite3stmt::cloneSet(c_sqlite3stmt *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3stmt
Variant c_sqlite3stmt::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x340A51AE22A924E0LL, reset) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD(0x436E6AFC3628E403LL, bindvalue) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(params[0], params[1]));
        return (t_bindvalue(params[0], params[1], params[2]));
      }
      break;
    case 7:
      HASH_GUARD(0x31DA235C5A226667LL, clear) {
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD(0x187C7F43EB57714ELL, execute) {
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD(0x77B13FCF1BA41696LL, bindparam) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        if (count <= 2) return (t_bindparam(params[0], ref(const_cast<Array&>(params).lvalAt(1))));
        return (t_bindparam(params[0], ref(const_cast<Array&>(params).lvalAt(1)), params[2]));
      }
      break;
    case 23:
      HASH_GUARD(0x72FA987001E93357LL, paramcount) {
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3stmt
Variant c_sqlite3stmt::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x340A51AE22A924E0LL, reset) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD(0x436E6AFC3628E403LL, bindvalue) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 7:
      HASH_GUARD(0x31DA235C5A226667LL, clear) {
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD(0x187C7F43EB57714ELL, execute) {
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD(0x77B13FCF1BA41696LL, bindparam) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 23:
      HASH_GUARD(0x72FA987001E93357LL, paramcount) {
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3stmt
Variant c_sqlite3stmt::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3stmt
Variant c_sqlite3stmt::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x340A51AE22A924E0LL, reset) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD(0x436E6AFC3628E403LL, bindvalue) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 7:
      HASH_GUARD(0x31DA235C5A226667LL, clear) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD(0x187C7F43EB57714ELL, execute) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD(0x77B13FCF1BA41696LL, bindparam) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 23:
      HASH_GUARD(0x72FA987001E93357LL, paramcount) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_sqlite3stmt::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_sqlite3stmt = {
  c_sqlite3stmt::os_getInit,
  c_sqlite3stmt::os_get,
  c_sqlite3stmt::os_lval,
  c_sqlite3stmt::os_invoke,
  c_sqlite3stmt::os_constant,
};
Object co_domnodelist(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnodelist)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnodelist
Variant c_domnodelist::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnodelist
Variant c_domnodelist::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnodelist
Variant &c_domnodelist::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnodelist
void c_domnodelist::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnodelist
Variant c_domnodelist::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domnodelist::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnodelist
Variant c_domnodelist::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnodelist
Variant c_domnodelist::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnodelist
bool c_domnodelist::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domnodelist::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnodelist
bool c_domnodelist::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnodelist
bool c_domnodelist::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnodelist
Variant c_domnodelist::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domnodelist::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnodelist
Variant c_domnodelist::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnodelist
Variant c_domnodelist::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnodelist
Variant& c_domnodelist::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domnodelist::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnodelist
Variant& c_domnodelist::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnodelist
Variant& c_domnodelist::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnodelist
Variant c_domnodelist::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnodelist
IMPLEMENT_CLASS(domnodelist)
c_domnodelist *c_domnodelist::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnodelist::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnodelist::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnodelist::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnodelist::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnodelist::cloneImpl() {
  c_domnodelist *obj = NEW(c_domnodelist)();
  cloneSet(obj);
  return obj;
}
void c_domnodelist::cloneSet(c_domnodelist *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_domnodelist::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnodelist
Variant c_domnodelist::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 6:
      HASH_GUARD(0x0A41DBE0830902C6LL, item) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(params[0]));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnodelist
Variant c_domnodelist::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD(0x0A41DBE0830902C6LL, item) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnodelist
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnodelist
Variant c_domnodelist::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnodelist
Variant c_domnodelist::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD(0x0A41DBE0830902C6LL, item) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnodelist::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnodelist = {
  c_domnodelist::os_getInit,
  c_domnodelist::os_get,
  c_domnodelist::os_lval,
  c_domnodelist::os_invoke,
  c_domnodelist::os_constant,
};
Object co_normalizer(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_normalizer)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_normalizer
Variant c_normalizer::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_normalizer
Variant c_normalizer::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_normalizer
Variant &c_normalizer::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_normalizer
void c_normalizer::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_get_normalizer
Variant c_normalizer::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_normalizer::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_normalizer
Variant c_normalizer::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_normalizer
Variant c_normalizer::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_exists_normalizer
bool c_normalizer::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_normalizer::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_normalizer
bool c_normalizer::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_normalizer
bool c_normalizer::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_set_normalizer
Variant c_normalizer::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_normalizer::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_normalizer
Variant c_normalizer::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_normalizer
Variant c_normalizer::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_lval_normalizer
Variant& c_normalizer::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_normalizer::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_normalizer
Variant& c_normalizer::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_normalizer
Variant& c_normalizer::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_normalizer
Variant c_normalizer::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 1:
      HASH_RETURN(0x3E3AA0A97BD09921LL, q_normalizer_NFKC, NFKC);
      break;
    case 6:
      HASH_RETURN(0x51422F059BEFCD86LL, q_normalizer_NFC, NFC);
      break;
    case 10:
      HASH_RETURN(0x74A3413C2B22BD6ALL, q_normalizer_FORM_KC, FORM_KC);
      break;
    case 14:
      HASH_RETURN(0x050A4511900DD0AELL, q_normalizer_FORM_KD, FORM_KD);
      break;
    case 15:
      HASH_RETURN(0x58B301790FA834EFLL, q_normalizer_NFD, NFD);
      break;
    case 16:
      HASH_RETURN(0x155E435B3A2CD690LL, q_normalizer_NFKD, NFKD);
      break;
    case 19:
      HASH_RETURN(0x2EFDCA1922BFB273LL, q_normalizer_NONE, NONE);
      break;
    case 27:
      HASH_RETURN(0x5FBDCED1A147AB3BLL, q_normalizer_FORM_D, FORM_D);
      break;
    case 31:
      HASH_RETURN(0x3BE3511FDA9A9E7FLL, q_normalizer_FORM_C, FORM_C);
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_normalizer
IMPLEMENT_CLASS(normalizer)
c_normalizer *c_normalizer::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_normalizer::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_normalizer::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_normalizer::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_normalizer::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_normalizer::cloneImpl() {
  c_normalizer *obj = NEW(c_normalizer)();
  cloneSet(obj);
  return obj;
}
void c_normalizer::cloneSet(c_normalizer *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_normalizer
Variant c_normalizer::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        if (count <= 1) return (ti_normalize(o_getClassName(), params[0]));
        return (ti_normalize(o_getClassName(), params[0], params[1]));
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD(0x58CF37E15F66ED1DLL, isnormalized) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        if (count <= 1) return (ti_isnormalized(o_getClassName(), params[0]));
        return (ti_isnormalized(o_getClassName(), params[0], params[1]));
      }
      break;
    case 7:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_normalizer
Variant c_normalizer::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD(0x58CF37E15F66ED1DLL, isnormalized) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    case 7:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_normalizer
Variant c_normalizer::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 1:
      HASH_GUARD(0x58CF37E15F66ED1DLL, isnormalized) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        if (count <= 1) return (ti_isnormalized(c, params[0]));
        return (ti_isnormalized(c, params[0], params[1]));
      }
      break;
    case 2:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        if (count <= 1) return (ti_normalize(c, params[0]));
        return (ti_normalize(c, params[0], params[1]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_normalizer
Variant c_normalizer::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        else return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD(0x58CF37E15F66ED1DLL, isnormalized) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        else return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    case 7:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_normalizer::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 1:
      HASH_GUARD(0x58CF37E15F66ED1DLL, isnormalized) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(c, a0));
        else return (ti_isnormalized(c, a0, a1));
      }
      break;
    case 2:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(c, a0));
        else return (ti_normalize(c, a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_normalizer = {
  c_normalizer::os_getInit,
  c_normalizer::os_get,
  c_normalizer::os_lval,
  c_normalizer::os_invoke,
  c_normalizer::os_constant,
};
Object co_domcharacterdata(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domcharacterdata)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcharacterdata
Variant c_domcharacterdata::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcharacterdata
Variant c_domcharacterdata::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcharacterdata
Variant &c_domcharacterdata::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domcharacterdata
void c_domcharacterdata::o_get(Array &props) const {
  c_domnode::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_get_domcharacterdata
Variant c_domcharacterdata::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domcharacterdata::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcharacterdata
Variant c_domcharacterdata::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcharacterdata
Variant c_domcharacterdata::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domcharacterdata
bool c_domcharacterdata::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domcharacterdata::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcharacterdata
bool c_domcharacterdata::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcharacterdata
bool c_domcharacterdata::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_set_domcharacterdata
Variant c_domcharacterdata::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domcharacterdata::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcharacterdata
Variant c_domcharacterdata::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcharacterdata
Variant c_domcharacterdata::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domcharacterdata
Variant& c_domcharacterdata::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domcharacterdata::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcharacterdata
Variant& c_domcharacterdata::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcharacterdata
Variant& c_domcharacterdata::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domcharacterdata
Variant c_domcharacterdata::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domcharacterdata
IMPLEMENT_CLASS(domcharacterdata)
c_domcharacterdata *c_domcharacterdata::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domcharacterdata::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domcharacterdata::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domcharacterdata::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domcharacterdata::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domcharacterdata::cloneImpl() {
  c_domcharacterdata *obj = NEW(c_domcharacterdata)();
  cloneSet(obj);
  return obj;
}
void c_domcharacterdata::cloneSet(c_domcharacterdata *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domcharacterdata::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcharacterdata
Variant c_domcharacterdata::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(params[0], params[1]));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(params[0], params[1]));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(params[0], params[1], params[2]));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(params[0], params[1]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcharacterdata
Variant c_domcharacterdata::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcharacterdata
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcharacterdata
Variant c_domcharacterdata::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcharacterdata
Variant c_domcharacterdata::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domcharacterdata::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domcharacterdata = {
  c_domcharacterdata::os_getInit,
  c_domcharacterdata::os_get,
  c_domcharacterdata::os_lval,
  c_domcharacterdata::os_invoke,
  c_domcharacterdata::os_constant,
};
Object co_domentityreference(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domentityreference)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domentityreference
Variant c_domentityreference::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domentityreference
Variant c_domentityreference::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domentityreference
Variant &c_domentityreference::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domentityreference
void c_domentityreference::o_get(Array &props) const {
  c_domnode::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_get_domentityreference
Variant c_domentityreference::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domentityreference::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domentityreference
Variant c_domentityreference::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domentityreference
Variant c_domentityreference::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domentityreference
bool c_domentityreference::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domentityreference::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domentityreference
bool c_domentityreference::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domentityreference
bool c_domentityreference::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_set_domentityreference
Variant c_domentityreference::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domentityreference::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domentityreference
Variant c_domentityreference::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domentityreference
Variant c_domentityreference::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domentityreference
Variant& c_domentityreference::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domentityreference::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domentityreference
Variant& c_domentityreference::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domentityreference
Variant& c_domentityreference::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domentityreference
Variant c_domentityreference::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domentityreference
IMPLEMENT_CLASS(domentityreference)
c_domentityreference *c_domentityreference::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domentityreference::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    (t___construct(params[0]));
  }
  return this;
}
void c_domentityreference::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  (t___construct(params[0]));
}
void c_domentityreference::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_domentityreference::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domentityreference::cloneImpl() {
  c_domentityreference *obj = NEW(c_domentityreference)();
  cloneSet(obj);
  return obj;
}
void c_domentityreference::cloneSet(c_domentityreference *clone) {
  c_domnode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domentityreference
Variant c_domentityreference::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(params[0]), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domentityreference
Variant c_domentityreference::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domentityreference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domentityreference
Variant c_domentityreference::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domentityreference
Variant c_domentityreference::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domentityreference::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domentityreference = {
  c_domentityreference::os_getInit,
  c_domentityreference::os_get,
  c_domentityreference::os_lval,
  c_domentityreference::os_invoke,
  c_domentityreference::os_constant,
};
Object co_simplexmlelementiterator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_simplexmlelementiterator)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_simplexmlelementiterator
Variant c_simplexmlelementiterator::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_simplexmlelementiterator
Variant c_simplexmlelementiterator::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_simplexmlelementiterator
Variant &c_simplexmlelementiterator::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_simplexmlelementiterator
void c_simplexmlelementiterator::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_simplexmlelementiterator::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_simplexmlelementiterator
bool c_simplexmlelementiterator::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_simplexmlelementiterator::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_simplexmlelementiterator
bool c_simplexmlelementiterator::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_simplexmlelementiterator
bool c_simplexmlelementiterator::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_simplexmlelementiterator::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_simplexmlelementiterator
Variant& c_simplexmlelementiterator::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_simplexmlelementiterator::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_simplexmlelementiterator
Variant& c_simplexmlelementiterator::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_simplexmlelementiterator
Variant& c_simplexmlelementiterator::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_simplexmlelementiterator
Variant c_simplexmlelementiterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_simplexmlelementiterator
IMPLEMENT_CLASS(simplexmlelementiterator)
c_simplexmlelementiterator *c_simplexmlelementiterator::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_simplexmlelementiterator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_simplexmlelementiterator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_simplexmlelementiterator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_simplexmlelementiterator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_simplexmlelementiterator::cloneImpl() {
  c_simplexmlelementiterator *obj = NEW(c_simplexmlelementiterator)();
  cloneSet(obj);
  return obj;
}
void c_simplexmlelementiterator::cloneSet(c_simplexmlelementiterator *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelementiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_simplexmlelementiterator
Variant c_simplexmlelementiterator::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_simplexmlelementiterator
Variant c_simplexmlelementiterator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_simplexmlelementiterator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_simplexmlelementiterator = {
  c_simplexmlelementiterator::os_getInit,
  c_simplexmlelementiterator::os_get,
  c_simplexmlelementiterator::os_lval,
  c_simplexmlelementiterator::os_invoke,
  c_simplexmlelementiterator::os_constant,
};
Object co_datetimezone(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_datetimezone)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_datetimezone
Variant c_datetimezone::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_datetimezone
Variant c_datetimezone::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_datetimezone
Variant &c_datetimezone::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_datetimezone
void c_datetimezone::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_get_datetimezone
Variant c_datetimezone::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_datetimezone::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_datetimezone
Variant c_datetimezone::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_datetimezone
Variant c_datetimezone::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_exists_datetimezone
bool c_datetimezone::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_datetimezone::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_datetimezone
bool c_datetimezone::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_datetimezone
bool c_datetimezone::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_set_datetimezone
Variant c_datetimezone::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_datetimezone::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_datetimezone
Variant c_datetimezone::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_datetimezone
Variant c_datetimezone::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_lval_datetimezone
Variant& c_datetimezone::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_datetimezone::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_datetimezone
Variant& c_datetimezone::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_datetimezone
Variant& c_datetimezone::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_datetimezone
Variant c_datetimezone::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_RETURN(0x63A9EAAA4EB8EBE0LL, q_datetimezone_AUSTRALIA, AUSTRALIA);
      break;
    case 2:
      HASH_RETURN(0x5213CDB166554802LL, q_datetimezone_AFRICA, AFRICA);
      break;
    case 6:
      HASH_RETURN(0x1E8CF4E6D83EBE26LL, q_datetimezone_ARCTIC, ARCTIC);
      break;
    case 11:
      HASH_RETURN(0x48267C78B9CF852BLL, q_datetimezone_UTC, UTC);
      break;
    case 13:
      HASH_RETURN(0x77D44F9E5B4E1B4DLL, q_datetimezone_EUROPE, EUROPE);
      break;
    case 14:
      HASH_RETURN(0x660826BF96BA51CELL, q_datetimezone_INDIAN, INDIAN);
      break;
    case 19:
      HASH_RETURN(0x7879534F49C301F3LL, q_datetimezone_PER_COUNTRY, PER_COUNTRY);
      break;
    case 20:
      HASH_RETURN(0x7B374AC71BDE5614LL, q_datetimezone_PACIFIC, PACIFIC);
      break;
    case 22:
      HASH_RETURN(0x5B22A02847A2D2D6LL, q_datetimezone_AMERICA, AMERICA);
      break;
    case 23:
      HASH_RETURN(0x5A01AACAA61F0FF7LL, q_datetimezone_ASIA, ASIA);
      break;
    case 24:
      HASH_RETURN(0x0C4F30470A9EEBF8LL, q_datetimezone_ALL, ALL);
      break;
    case 25:
      HASH_RETURN(0x2BEDCED53E62BC79LL, q_datetimezone_ATLANTIC, ATLANTIC);
      break;
    case 30:
      HASH_RETURN(0x690180C3BA732B5ELL, q_datetimezone_ALL_WITH_BC, ALL_WITH_BC);
      break;
    case 31:
      HASH_RETURN(0x6B29DE65F46EAFDFLL, q_datetimezone_ANTARCTICA, ANTARCTICA);
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_datetimezone
IMPLEMENT_CLASS(datetimezone)
c_datetimezone *c_datetimezone::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_datetimezone::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    (t___construct(params[0]));
  }
  return this;
}
void c_datetimezone::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  (t___construct(params[0]));
}
void c_datetimezone::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_datetimezone::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_datetimezone::cloneImpl() {
  c_datetimezone *obj = NEW(c_datetimezone)();
  cloneSet(obj);
  return obj;
}
void c_datetimezone::cloneSet(c_datetimezone *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_datetimezone
Variant c_datetimezone::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x6D7CD16BBA93D063LL, listidentifiers) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x63D3CF3884CE93F4LL, gettransitions) {
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x2D0CCAB16C3ED068LL, listabbreviations) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD(0x68DB66F60B55BD0BLL, getoffset) {
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        return (t_getoffset(params[0]));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(params[0]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_datetimezone
Variant c_datetimezone::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x6D7CD16BBA93D063LL, listidentifiers) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x63D3CF3884CE93F4LL, gettransitions) {
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x2D0CCAB16C3ED068LL, listabbreviations) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD(0x68DB66F60B55BD0BLL, getoffset) {
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        return (t_getoffset(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_datetimezone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_datetimezone
Variant c_datetimezone::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 0:
      HASH_GUARD(0x2D0CCAB16C3ED068LL, listabbreviations) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(c));
      }
      break;
    case 3:
      HASH_GUARD(0x6D7CD16BBA93D063LL, listidentifiers) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(c));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_datetimezone
Variant c_datetimezone::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x6D7CD16BBA93D063LL, listidentifiers) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x63D3CF3884CE93F4LL, gettransitions) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x2D0CCAB16C3ED068LL, listabbreviations) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD(0x68DB66F60B55BD0BLL, getoffset) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_datetimezone::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 0:
      HASH_GUARD(0x2D0CCAB16C3ED068LL, listabbreviations) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(c));
      }
      break;
    case 3:
      HASH_GUARD(0x6D7CD16BBA93D063LL, listidentifiers) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(c));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_datetimezone = {
  c_datetimezone::os_getInit,
  c_datetimezone::os_get,
  c_datetimezone::os_lval,
  c_datetimezone::os_invoke,
  c_datetimezone::os_constant,
};
Object co_domnodeiterator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnodeiterator)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnodeiterator
Variant c_domnodeiterator::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnodeiterator
Variant c_domnodeiterator::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnodeiterator
Variant &c_domnodeiterator::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnodeiterator
void c_domnodeiterator::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnodeiterator
Variant c_domnodeiterator::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domnodeiterator::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnodeiterator
Variant c_domnodeiterator::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnodeiterator
Variant c_domnodeiterator::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnodeiterator
bool c_domnodeiterator::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domnodeiterator::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnodeiterator
bool c_domnodeiterator::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnodeiterator
bool c_domnodeiterator::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnodeiterator
Variant c_domnodeiterator::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domnodeiterator::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnodeiterator
Variant c_domnodeiterator::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnodeiterator
Variant c_domnodeiterator::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnodeiterator
Variant& c_domnodeiterator::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domnodeiterator::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnodeiterator
Variant& c_domnodeiterator::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnodeiterator
Variant& c_domnodeiterator::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnodeiterator
Variant c_domnodeiterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnodeiterator
IMPLEMENT_CLASS(domnodeiterator)
c_domnodeiterator *c_domnodeiterator::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnodeiterator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnodeiterator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnodeiterator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnodeiterator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnodeiterator::cloneImpl() {
  c_domnodeiterator *obj = NEW(c_domnodeiterator)();
  cloneSet(obj);
  return obj;
}
void c_domnodeiterator::cloneSet(c_domnodeiterator *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnodeiterator
Variant c_domnodeiterator::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnodeiterator
Variant c_domnodeiterator::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnodeiterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnodeiterator
Variant c_domnodeiterator::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnodeiterator
Variant c_domnodeiterator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnodeiterator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnodeiterator = {
  c_domnodeiterator::os_getInit,
  c_domnodeiterator::os_get,
  c_domnodeiterator::os_lval,
  c_domnodeiterator::os_invoke,
  c_domnodeiterator::os_constant,
};
Object co_domimplementation(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domimplementation)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domimplementation
Variant c_domimplementation::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domimplementation
Variant c_domimplementation::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domimplementation
Variant &c_domimplementation::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domimplementation
void c_domimplementation::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_get_domimplementation
Variant c_domimplementation::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domimplementation::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domimplementation
Variant c_domimplementation::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domimplementation
Variant c_domimplementation::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domimplementation
bool c_domimplementation::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domimplementation::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domimplementation
bool c_domimplementation::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domimplementation
bool c_domimplementation::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_set_domimplementation
Variant c_domimplementation::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domimplementation::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domimplementation
Variant c_domimplementation::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domimplementation
Variant c_domimplementation::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domimplementation
Variant& c_domimplementation::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domimplementation::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domimplementation
Variant& c_domimplementation::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domimplementation
Variant& c_domimplementation::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domimplementation
Variant c_domimplementation::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domimplementation
IMPLEMENT_CLASS(domimplementation)
c_domimplementation *c_domimplementation::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domimplementation::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domimplementation::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domimplementation::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domimplementation::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domimplementation::cloneImpl() {
  c_domimplementation *obj = NEW(c_domimplementation)();
  cloneSet(obj);
  return obj;
}
void c_domimplementation::cloneSet(c_domimplementation *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domimplementation
Variant c_domimplementation::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x3CB56A796F3DBAC3LL, createdocumenttype) {
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        if (count <= 0) return (t_createdocumenttype());
        if (count == 1) return (t_createdocumenttype(params[0]));
        if (count == 2) return (t_createdocumenttype(params[0], params[1]));
        return (t_createdocumenttype(params[0], params[1], params[2]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x280878EAC306A6A3LL, hasfeature) {
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        return (t_hasfeature(params[0], params[1]));
      }
      break;
    case 14:
      HASH_GUARD(0x30855E95B37D1B4ELL, createdocument) {
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        if (count <= 0) return (t_createdocument());
        if (count == 1) return (t_createdocument(params[0]));
        if (count == 2) return (t_createdocument(params[0], params[1]));
        return (t_createdocument(params[0], params[1], params[2]));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domimplementation
Variant c_domimplementation::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x3CB56A796F3DBAC3LL, createdocumenttype) {
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        if (count <= 0) return (t_createdocumenttype());
        if (count == 1) return (t_createdocumenttype(a0));
        if (count == 2) return (t_createdocumenttype(a0, a1));
        return (t_createdocumenttype(a0, a1, a2));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x280878EAC306A6A3LL, hasfeature) {
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        return (t_hasfeature(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD(0x30855E95B37D1B4ELL, createdocument) {
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        if (count <= 0) return (t_createdocument());
        if (count == 1) return (t_createdocument(a0));
        if (count == 2) return (t_createdocument(a0, a1));
        return (t_createdocument(a0, a1, a2));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domimplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domimplementation
Variant c_domimplementation::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domimplementation
Variant c_domimplementation::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x3CB56A796F3DBAC3LL, createdocumenttype) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocumenttype());
        else if (count == 1) return (t_createdocumenttype(a0));
        else if (count == 2) return (t_createdocumenttype(a0, a1));
        else return (t_createdocumenttype(a0, a1, a2));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x280878EAC306A6A3LL, hasfeature) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasfeature(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD(0x30855E95B37D1B4ELL, createdocument) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocument());
        else if (count == 1) return (t_createdocument(a0));
        else if (count == 2) return (t_createdocument(a0, a1));
        else return (t_createdocument(a0, a1, a2));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domimplementation::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domimplementation = {
  c_domimplementation::os_getInit,
  c_domimplementation::os_get,
  c_domimplementation::os_lval,
  c_domimplementation::os_invoke,
  c_domimplementation::os_constant,
};
Object co_soapheader(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapheader)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapheader
Variant c_soapheader::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapheader
Variant c_soapheader::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapheader
Variant &c_soapheader::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapheader
void c_soapheader::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapheader
Variant c_soapheader::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_soapheader::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapheader
Variant c_soapheader::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapheader
Variant c_soapheader::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapheader
bool c_soapheader::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_soapheader::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapheader
bool c_soapheader::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapheader
bool c_soapheader::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapheader
Variant c_soapheader::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_soapheader::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapheader
Variant c_soapheader::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapheader
Variant c_soapheader::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapheader
Variant& c_soapheader::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_soapheader::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapheader
Variant& c_soapheader::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapheader
Variant& c_soapheader::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapheader
Variant c_soapheader::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapheader
IMPLEMENT_CLASS(soapheader)
c_soapheader *c_soapheader::create(String a0, String a1, Variant a2, bool a3, Variant a4) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4);
  return this;
}
ObjectData *c_soapheader::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 2);
    if (count <= 2) (t___construct(params[0], params[1]));
    else if (count == 3) (t___construct(params[0], params[1], params[2]));
    else if (count == 4) (t___construct(params[0], params[1], params[2], params[3]));
    else (t___construct(params[0], params[1], params[2], params[3], params[4]));
  }
  return this;
}
void c_soapheader::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 2);
  if (count <= 2) (t___construct(params[0], params[1]));
  else if (count == 3) (t___construct(params[0], params[1], params[2]));
  else if (count == 4) (t___construct(params[0], params[1], params[2], params[3]));
  else (t___construct(params[0], params[1], params[2], params[3], params[4]));
}
void c_soapheader::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
void c_soapheader::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapheader::cloneImpl() {
  c_soapheader *obj = NEW(c_soapheader)();
  cloneSet(obj);
  return obj;
}
void c_soapheader::cloneSet(c_soapheader *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapheader
Variant c_soapheader::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        if (count <= 2) return (t___construct(params[0], params[1]), null);
        if (count == 3) return (t___construct(params[0], params[1], params[2]), null);
        if (count == 4) return (t___construct(params[0], params[1], params[2], params[3]), null);
        return (t___construct(params[0], params[1], params[2], params[3], params[4]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapheader
Variant c_soapheader::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapheader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapheader
Variant c_soapheader::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapheader
Variant c_soapheader::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapheader::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapheader = {
  c_soapheader::os_getInit,
  c_soapheader::os_get,
  c_soapheader::os_lval,
  c_soapheader::os_invoke,
  c_soapheader::os_constant,
};
Object co_domnotation(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnotation)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnotation
Variant c_domnotation::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnotation
Variant c_domnotation::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnotation
Variant &c_domnotation::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnotation
void c_domnotation::o_get(Array &props) const {
  c_domnode::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnotation
Variant c_domnotation::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domnotation::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnotation
Variant c_domnotation::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnotation
Variant c_domnotation::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnotation
bool c_domnotation::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domnotation::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnotation
bool c_domnotation::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnotation
bool c_domnotation::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnotation
Variant c_domnotation::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domnotation::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnotation
Variant c_domnotation::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnotation
Variant c_domnotation::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnotation
Variant& c_domnotation::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domnotation::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnotation
Variant& c_domnotation::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnotation
Variant& c_domnotation::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnotation
Variant c_domnotation::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnotation
IMPLEMENT_CLASS(domnotation)
c_domnotation *c_domnotation::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnotation::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnotation::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnotation::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnotation::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnotation::cloneImpl() {
  c_domnotation *obj = NEW(c_domnotation)();
  cloneSet(obj);
  return obj;
}
void c_domnotation::cloneSet(c_domnotation *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domnotation::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnotation
Variant c_domnotation::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnotation
Variant c_domnotation::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnotation
Variant c_domnotation::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnotation
Variant c_domnotation::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnotation::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnotation = {
  c_domnotation::os_getInit,
  c_domnotation::os_get,
  c_domnotation::os_lval,
  c_domnotation::os_invoke,
  c_domnotation::os_constant,
};
Object co_concurrenthash(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_concurrenthash)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_concurrenthash
Variant c_concurrenthash::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_concurrenthash
Variant c_concurrenthash::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_concurrenthash
Variant &c_concurrenthash::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_concurrenthash
void c_concurrenthash::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_get_concurrenthash
Variant c_concurrenthash::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_concurrenthash::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_concurrenthash
Variant c_concurrenthash::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_concurrenthash
Variant c_concurrenthash::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_exists_concurrenthash
bool c_concurrenthash::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_concurrenthash::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_concurrenthash
bool c_concurrenthash::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_concurrenthash
bool c_concurrenthash::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_set_concurrenthash
Variant c_concurrenthash::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_concurrenthash::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_concurrenthash
Variant c_concurrenthash::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_concurrenthash
Variant c_concurrenthash::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_lval_concurrenthash
Variant& c_concurrenthash::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_concurrenthash::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_concurrenthash
Variant& c_concurrenthash::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_concurrenthash
Variant& c_concurrenthash::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_concurrenthash
Variant c_concurrenthash::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_concurrenthash
IMPLEMENT_CLASS(concurrenthash)
c_concurrenthash *c_concurrenthash::create(Array a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_concurrenthash::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    if (count <= 0) (t___construct());
    else (t___construct(params[0]));
  }
  return this;
}
void c_concurrenthash::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  if (count <= 0) (t___construct());
  else (t___construct(params[0]));
}
void c_concurrenthash::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
void c_concurrenthash::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_concurrenthash::cloneImpl() {
  c_concurrenthash *obj = NEW(c_concurrenthash)();
  cloneSet(obj);
  return obj;
}
void c_concurrenthash::cloneSet(c_concurrenthash *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_concurrenthash
Variant c_concurrenthash::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD(0x3A88D49C06AF8890LL, size) {
        if (count > 0) return throw_toomany_arguments("size", 0, 1);
        return (t_size());
      }
      break;
    case 3:
      HASH_GUARD(0x2A9C172C6A3B5403LL, find) {
        if (count != 1) return throw_wrong_arguments("find", count, 1, 1, 1);
        return (t_find(params[0]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 8:
      HASH_GUARD(0x1C453724CCB144B8LL, as_array) {
        if (count > 0) return throw_toomany_arguments("as_array", 0, 1);
        return (t_as_array());
      }
      break;
    case 13:
      HASH_GUARD(0x00DFE2FA5EA20DEDLL, erase) {
        if (count != 1) return throw_wrong_arguments("erase", count, 1, 1, 1);
        return (t_erase(params[0]), null);
      }
      break;
    case 14:
      HASH_GUARD(0x61F327248511D92ELL, insert) {
        if (count != 2) return throw_wrong_arguments("insert", count, 2, 2, 1);
        return (t_insert(params[0], params[1]), null);
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(params[0]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_concurrenthash
Variant c_concurrenthash::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD(0x3A88D49C06AF8890LL, size) {
        if (count > 0) return throw_toomany_arguments("size", 0, 1);
        return (t_size());
      }
      break;
    case 3:
      HASH_GUARD(0x2A9C172C6A3B5403LL, find) {
        if (count != 1) return throw_wrong_arguments("find", count, 1, 1, 1);
        return (t_find(a0));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 8:
      HASH_GUARD(0x1C453724CCB144B8LL, as_array) {
        if (count > 0) return throw_toomany_arguments("as_array", 0, 1);
        return (t_as_array());
      }
      break;
    case 13:
      HASH_GUARD(0x00DFE2FA5EA20DEDLL, erase) {
        if (count != 1) return throw_wrong_arguments("erase", count, 1, 1, 1);
        return (t_erase(a0), null);
      }
      break;
    case 14:
      HASH_GUARD(0x61F327248511D92ELL, insert) {
        if (count != 2) return throw_wrong_arguments("insert", count, 2, 2, 1);
        return (t_insert(a0, a1), null);
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_concurrenthash
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_concurrenthash
Variant c_concurrenthash::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_concurrenthash
Variant c_concurrenthash::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD(0x3A88D49C06AF8890LL, size) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("size", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_size());
      }
      break;
    case 3:
      HASH_GUARD(0x2A9C172C6A3B5403LL, find) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("find", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_find(a0));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 8:
      HASH_GUARD(0x1C453724CCB144B8LL, as_array) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("as_array", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_as_array());
      }
      break;
    case 13:
      HASH_GUARD(0x00DFE2FA5EA20DEDLL, erase) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("erase", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_erase(a0), null);
      }
      break;
    case 14:
      HASH_GUARD(0x61F327248511D92ELL, insert) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insert", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insert(a0, a1), null);
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_concurrenthash::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_concurrenthash = {
  c_concurrenthash::os_getInit,
  c_concurrenthash::os_get,
  c_concurrenthash::os_lval,
  c_concurrenthash::os_invoke,
  c_concurrenthash::os_constant,
};
Object co_domcomment(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domcomment)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcomment
Variant c_domcomment::os_getInit(const char *s, int64 hash) {
  return c_domcharacterdata::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcomment
Variant c_domcomment::os_get(const char *s, int64 hash) {
  return c_domcharacterdata::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcomment
Variant &c_domcomment::os_lval(const char *s, int64 hash) {
  return c_domcharacterdata::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domcomment
void c_domcomment::o_get(Array &props) const {
  c_domcharacterdata::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_get_domcomment
Variant c_domcomment::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domcomment::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcomment
Variant c_domcomment::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_domcharacterdata::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcomment
Variant c_domcomment::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domcomment
bool c_domcomment::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domcomment::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcomment
bool c_domcomment::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domcharacterdata::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcomment
bool c_domcomment::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_set_domcomment
Variant c_domcomment::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domcomment::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcomment
Variant c_domcomment::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_domcharacterdata::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcomment
Variant c_domcomment::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domcomment
Variant& c_domcomment::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domcomment::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcomment
Variant& c_domcomment::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domcharacterdata::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcomment
Variant& c_domcomment::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domcomment
Variant c_domcomment::os_constant(const char *s) {
  return c_domcharacterdata::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domcomment
IMPLEMENT_CLASS(domcomment)
c_domcomment *c_domcomment::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domcomment::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    if (count <= 0) (t___construct());
    else (t___construct(params[0]));
  }
  return this;
}
void c_domcomment::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  if (count <= 0) (t___construct());
  else (t___construct(params[0]));
}
void c_domcomment::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
void c_domcomment::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domcomment::cloneImpl() {
  c_domcomment *obj = NEW(c_domcomment)();
  cloneSet(obj);
  return obj;
}
void c_domcomment::cloneSet(c_domcomment *clone) {
  c_domcharacterdata::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcomment
Variant c_domcomment::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(params[0], params[1]));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(params[0]), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(params[0], params[1]));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(params[0], params[1], params[2]));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(params[0], params[1]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domcomment
Variant c_domcomment::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domcomment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcomment
Variant c_domcomment::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domcomment
Variant c_domcomment::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD(0x7543EC746714D118LL, deletedata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x3DAC04A51FD2D92DLL, appenddata) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD(0x2D8D2253C2149972LL, substringdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD(0x470F2F0EA1F3D4B4LL, replacedata) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD(0x0E19CE7886BCEF3DLL, insertdata) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_domcharacterdata::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domcomment::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domcharacterdata::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domcomment = {
  c_domcomment::os_getInit,
  c_domcomment::os_get,
  c_domcomment::os_lval,
  c_domcomment::os_invoke,
  c_domcomment::os_constant,
};
Object co_sqlite3(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_sqlite3)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3
Variant c_sqlite3::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3
Variant c_sqlite3::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3
Variant &c_sqlite3::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3
void c_sqlite3::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_get_sqlite3
Variant c_sqlite3::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_sqlite3::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3
Variant c_sqlite3::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3
Variant c_sqlite3::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_exists_sqlite3
bool c_sqlite3::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_sqlite3::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3
bool c_sqlite3::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3
bool c_sqlite3::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_set_sqlite3
Variant c_sqlite3::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_sqlite3::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3
Variant c_sqlite3::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3
Variant c_sqlite3::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_lval_sqlite3
Variant& c_sqlite3::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_sqlite3::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3
Variant& c_sqlite3::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3
Variant& c_sqlite3::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3
Variant c_sqlite3::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3
IMPLEMENT_CLASS(sqlite3)
c_sqlite3 *c_sqlite3::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_sqlite3::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_sqlite3::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_sqlite3::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_sqlite3::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_sqlite3::cloneImpl() {
  c_sqlite3 *obj = NEW(c_sqlite3)();
  cloneSet(obj);
  return obj;
}
void c_sqlite3::cloneSet(c_sqlite3 *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3
Variant c_sqlite3::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD(0x6081F282094466C2LL, lasterrormsg) {
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        return (t_lasterrormsg());
      }
      HASH_GUARD(0x65BD6700742BF3C2LL, openblob) {
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        if (count <= 3) return (t_openblob(params[0], params[1], params[2]));
        return (t_openblob(params[0], params[1], params[2], params[3]));
      }
      break;
    case 3:
      HASH_GUARD(0x3AA4CCEC6BD68143LL, createaggregate) {
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        if (count <= 3) return (t_createaggregate(params[0], params[1], params[2]));
        return (t_createaggregate(params[0], params[1], params[2], params[3]));
      }
      break;
    case 4:
      HASH_GUARD(0x21F68C010C124BC4LL, open) {
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        if (count <= 1) return (t_open(params[0]), null);
        if (count == 2) return (t_open(params[0], params[1]), null);
        return (t_open(params[0], params[1], params[2]), null);
      }
      break;
    case 10:
      HASH_GUARD(0x632B468FC2FCAB0ALL, lasterrorcode) {
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD(0x4F1D1ED7B087208CLL, exec) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(params[0]));
      }
      break;
    case 13:
      HASH_GUARD(0x7CECF508291057CDLL, createfunction) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        if (count <= 2) return (t_createfunction(params[0], params[1]));
        return (t_createfunction(params[0], params[1], params[2]));
      }
      break;
    case 25:
      HASH_GUARD(0x64D2BDB189B02819LL, changes) {
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD(0x1B3CDE890A487664LL, loadextension) {
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        return (t_loadextension(params[0]));
      }
      break;
    case 38:
      HASH_GUARD(0x5024F08DB0FDCBE6LL, lastinsertrowid) {
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD(0x5AE41239FF63D86ALL, version) {
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD(0x156B1FAE4132ABEELL, querysingle) {
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        if (count <= 1) return (t_querysingle(params[0]));
        return (t_querysingle(params[0], params[1]));
      }
      break;
    case 47:
      HASH_GUARD(0x540020AE4BA591AFLL, prepare) {
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        return (t_prepare(params[0]));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x607C4C73BB251635LL, escapestring) {
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        return (t_escapestring(params[0]));
      }
      break;
    case 55:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(params[0]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3
Variant c_sqlite3::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD(0x6081F282094466C2LL, lasterrormsg) {
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        return (t_lasterrormsg());
      }
      HASH_GUARD(0x65BD6700742BF3C2LL, openblob) {
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        if (count <= 3) return (t_openblob(a0, a1, a2));
        return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 3:
      HASH_GUARD(0x3AA4CCEC6BD68143LL, createaggregate) {
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 4:
      HASH_GUARD(0x21F68C010C124BC4LL, open) {
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        if (count <= 1) return (t_open(a0), null);
        if (count == 2) return (t_open(a0, a1), null);
        return (t_open(a0, a1, a2), null);
      }
      break;
    case 10:
      HASH_GUARD(0x632B468FC2FCAB0ALL, lasterrorcode) {
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD(0x4F1D1ED7B087208CLL, exec) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 13:
      HASH_GUARD(0x7CECF508291057CDLL, createfunction) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        if (count <= 2) return (t_createfunction(a0, a1));
        return (t_createfunction(a0, a1, a2));
      }
      break;
    case 25:
      HASH_GUARD(0x64D2BDB189B02819LL, changes) {
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD(0x1B3CDE890A487664LL, loadextension) {
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        return (t_loadextension(a0));
      }
      break;
    case 38:
      HASH_GUARD(0x5024F08DB0FDCBE6LL, lastinsertrowid) {
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD(0x5AE41239FF63D86ALL, version) {
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD(0x156B1FAE4132ABEELL, querysingle) {
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        if (count <= 1) return (t_querysingle(a0));
        return (t_querysingle(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD(0x540020AE4BA591AFLL, prepare) {
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        return (t_prepare(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x607C4C73BB251635LL, escapestring) {
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        return (t_escapestring(a0));
      }
      break;
    case 55:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3
Variant c_sqlite3::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3
Variant c_sqlite3::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x78AE97BFBEBF5341LL, close) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD(0x6081F282094466C2LL, lasterrormsg) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrormsg());
      }
      HASH_GUARD(0x65BD6700742BF3C2LL, openblob) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_openblob(a0, a1, a2));
        else return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 3:
      HASH_GUARD(0x3AA4CCEC6BD68143LL, createaggregate) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        else return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 4:
      HASH_GUARD(0x21F68C010C124BC4LL, open) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_open(a0), null);
        else if (count == 2) return (t_open(a0, a1), null);
        else return (t_open(a0, a1, a2), null);
      }
      break;
    case 10:
      HASH_GUARD(0x632B468FC2FCAB0ALL, lasterrorcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD(0x4F1D1ED7B087208CLL, exec) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 13:
      HASH_GUARD(0x7CECF508291057CDLL, createfunction) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createfunction(a0, a1));
        else return (t_createfunction(a0, a1, a2));
      }
      break;
    case 25:
      HASH_GUARD(0x64D2BDB189B02819LL, changes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD(0x1B3CDE890A487664LL, loadextension) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadextension(a0));
      }
      break;
    case 38:
      HASH_GUARD(0x5024F08DB0FDCBE6LL, lastinsertrowid) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD(0x5AE41239FF63D86ALL, version) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD(0x156B1FAE4132ABEELL, querysingle) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_querysingle(a0));
        else return (t_querysingle(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD(0x540020AE4BA591AFLL, prepare) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_prepare(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x607C4C73BB251635LL, escapestring) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_escapestring(a0));
      }
      break;
    case 55:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_sqlite3::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_sqlite3 = {
  c_sqlite3::os_getInit,
  c_sqlite3::os_get,
  c_sqlite3::os_lval,
  c_sqlite3::os_invoke,
  c_sqlite3::os_constant,
};
Object co_domattr(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domattr)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domattr
Variant c_domattr::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domattr
Variant c_domattr::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domattr
Variant &c_domattr::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domattr
void c_domattr::o_get(Array &props) const {
  c_domnode::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_get_domattr
Variant c_domattr::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domattr::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domattr
Variant c_domattr::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domattr
Variant c_domattr::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domattr
bool c_domattr::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domattr::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domattr
bool c_domattr::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domattr
bool c_domattr::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_set_domattr
Variant c_domattr::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domattr::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domattr
Variant c_domattr::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domattr
Variant c_domattr::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domattr
Variant& c_domattr::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domattr::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domattr
Variant& c_domattr::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domattr
Variant& c_domattr::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domattr
Variant c_domattr::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domattr
IMPLEMENT_CLASS(domattr)
c_domattr *c_domattr::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_domattr::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    if (count <= 1) (t___construct(params[0]));
    else (t___construct(params[0], params[1]));
  }
  return this;
}
void c_domattr::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  if (count <= 1) (t___construct(params[0]));
  else (t___construct(params[0], params[1]));
}
void c_domattr::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_domattr::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domattr::cloneImpl() {
  c_domattr *obj = NEW(c_domattr)();
  cloneSet(obj);
  return obj;
}
void c_domattr::cloneSet(c_domattr *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domattr::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domattr
Variant c_domattr::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      HASH_GUARD(0x30A9329415D17F24LL, isid) {
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        return (t_isid());
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domattr
Variant c_domattr::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      HASH_GUARD(0x30A9329415D17F24LL, isid) {
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        return (t_isid());
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domattr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domattr
Variant c_domattr::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domattr
Variant c_domattr::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      HASH_GUARD(0x30A9329415D17F24LL, isid) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isid());
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domattr::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domattr = {
  c_domattr::os_getInit,
  c_domattr::os_get,
  c_domattr::os_lval,
  c_domattr::os_invoke,
  c_domattr::os_constant,
};
Object co_soapvar(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapvar)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapvar
Variant c_soapvar::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapvar
Variant c_soapvar::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapvar
Variant &c_soapvar::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapvar
void c_soapvar::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapvar
Variant c_soapvar::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_soapvar::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapvar
Variant c_soapvar::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapvar
Variant c_soapvar::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapvar
bool c_soapvar::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_soapvar::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapvar
bool c_soapvar::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapvar
bool c_soapvar::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapvar
Variant c_soapvar::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_soapvar::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapvar
Variant c_soapvar::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapvar
Variant c_soapvar::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapvar
Variant& c_soapvar::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_soapvar::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapvar
Variant& c_soapvar::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapvar
Variant& c_soapvar::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapvar
Variant c_soapvar::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapvar
IMPLEMENT_CLASS(soapvar)
c_soapvar *c_soapvar::create(Variant a0, Variant a1, String a2, String a3, String a4, String a5) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4, a5);
  return this;
}
ObjectData *c_soapvar::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
    if (count <= 2) (t___construct(params[0], params[1]));
    else if (count == 3) (t___construct(params[0], params[1], params[2]));
    else if (count == 4) (t___construct(params[0], params[1], params[2], params[3]));
    else if (count == 5) (t___construct(params[0], params[1], params[2], params[3], params[4]));
    else (t___construct(params[0], params[1], params[2], params[3], params[4], params[5]));
  }
  return this;
}
void c_soapvar::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
  if (count <= 2) (t___construct(params[0], params[1]));
  else if (count == 3) (t___construct(params[0], params[1], params[2]));
  else if (count == 4) (t___construct(params[0], params[1], params[2], params[3]));
  else if (count == 5) (t___construct(params[0], params[1], params[2], params[3], params[4]));
  else (t___construct(params[0], params[1], params[2], params[3], params[4], params[5]));
}
void c_soapvar::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else if (count == 5) (t___construct(a0, a1, a2, a3, a4), null);
  else (t___construct(a0, a1, a2, a3, a4, a5), null);
}
void c_soapvar::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapvar::cloneImpl() {
  c_soapvar *obj = NEW(c_soapvar)();
  cloneSet(obj);
  return obj;
}
void c_soapvar::cloneSet(c_soapvar *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapvar
Variant c_soapvar::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(params[0], params[1]), null);
        if (count == 3) return (t___construct(params[0], params[1], params[2]), null);
        if (count == 4) return (t___construct(params[0], params[1], params[2], params[3]), null);
        if (count == 5) return (t___construct(params[0], params[1], params[2], params[3], params[4]), null);
        return (t___construct(params[0], params[1], params[2], params[3], params[4], params[5]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapvar
Variant c_soapvar::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapvar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapvar
Variant c_soapvar::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapvar
Variant c_soapvar::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapvar::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapvar = {
  c_soapvar::os_getInit,
  c_soapvar::os_get,
  c_soapvar::os_lval,
  c_soapvar::os_invoke,
  c_soapvar::os_constant,
};
Object co_domnamednodemap(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnamednodemap)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnamednodemap
Variant c_domnamednodemap::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnamednodemap
Variant c_domnamednodemap::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnamednodemap
Variant &c_domnamednodemap::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnamednodemap
void c_domnamednodemap::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnamednodemap
Variant c_domnamednodemap::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domnamednodemap::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnamednodemap
Variant c_domnamednodemap::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnamednodemap
Variant c_domnamednodemap::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnamednodemap
bool c_domnamednodemap::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domnamednodemap::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnamednodemap
bool c_domnamednodemap::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnamednodemap
bool c_domnamednodemap::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnamednodemap
Variant c_domnamednodemap::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domnamednodemap::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnamednodemap
Variant c_domnamednodemap::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnamednodemap
Variant c_domnamednodemap::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnamednodemap
Variant& c_domnamednodemap::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domnamednodemap::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnamednodemap
Variant& c_domnamednodemap::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnamednodemap
Variant& c_domnamednodemap::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnamednodemap
Variant c_domnamednodemap::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnamednodemap
IMPLEMENT_CLASS(domnamednodemap)
c_domnamednodemap *c_domnamednodemap::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnamednodemap::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnamednodemap::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnamednodemap::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnamednodemap::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnamednodemap::cloneImpl() {
  c_domnamednodemap *obj = NEW(c_domnamednodemap)();
  cloneSet(obj);
  return obj;
}
void c_domnamednodemap::cloneSet(c_domnamednodemap *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_domnamednodemap::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnamednodemap
Variant c_domnamednodemap::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 6:
      HASH_GUARD(0x0A41DBE0830902C6LL, item) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(params[0]));
      }
      break;
    case 10:
      HASH_GUARD(0x5D3CEC627F9ADC3ALL, getnameditem) {
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        return (t_getnameditem(params[0]));
      }
      break;
    case 11:
      HASH_GUARD(0x53B4D840FF4F0F1BLL, getnameditemns) {
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        return (t_getnameditemns(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnamednodemap
Variant c_domnamednodemap::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD(0x0A41DBE0830902C6LL, item) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 10:
      HASH_GUARD(0x5D3CEC627F9ADC3ALL, getnameditem) {
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        return (t_getnameditem(a0));
      }
      break;
    case 11:
      HASH_GUARD(0x53B4D840FF4F0F1BLL, getnameditemns) {
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        return (t_getnameditemns(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnamednodemap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnamednodemap
Variant c_domnamednodemap::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnamednodemap
Variant c_domnamednodemap::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD(0x0A41DBE0830902C6LL, item) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 10:
      HASH_GUARD(0x5D3CEC627F9ADC3ALL, getnameditem) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditem(a0));
      }
      break;
    case 11:
      HASH_GUARD(0x53B4D840FF4F0F1BLL, getnameditemns) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditemns(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnamednodemap::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnamednodemap = {
  c_domnamednodemap::os_getInit,
  c_domnamednodemap::os_get,
  c_domnamednodemap::os_lval,
  c_domnamednodemap::os_invoke,
  c_domnamednodemap::os_constant,
};
Object co_sqlite3result(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_sqlite3result)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3result
Variant c_sqlite3result::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3result
Variant c_sqlite3result::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3result
Variant &c_sqlite3result::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3result
void c_sqlite3result::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_get_sqlite3result
Variant c_sqlite3result::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_sqlite3result::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3result
Variant c_sqlite3result::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3result
Variant c_sqlite3result::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_exists_sqlite3result
bool c_sqlite3result::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_sqlite3result::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3result
bool c_sqlite3result::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3result
bool c_sqlite3result::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_set_sqlite3result
Variant c_sqlite3result::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_sqlite3result::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3result
Variant c_sqlite3result::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3result
Variant c_sqlite3result::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_lval_sqlite3result
Variant& c_sqlite3result::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_sqlite3result::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3result
Variant& c_sqlite3result::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3result
Variant& c_sqlite3result::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3result
Variant c_sqlite3result::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_sqlite3result
IMPLEMENT_CLASS(sqlite3result)
c_sqlite3result *c_sqlite3result::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_sqlite3result::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_sqlite3result::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_sqlite3result::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_sqlite3result::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_sqlite3result::cloneImpl() {
  c_sqlite3result *obj = NEW(c_sqlite3result)();
  cloneSet(obj);
  return obj;
}
void c_sqlite3result::cloneSet(c_sqlite3result *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3result
Variant c_sqlite3result::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD(0x340A51AE22A924E0LL, reset) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD(0x4C7702FC22784996LL, numcolumns) {
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD(0x696EFC04EE7E47F8LL, columnname) {
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        return (t_columnname(params[0]));
      }
      break;
    case 11:
      HASH_GUARD(0x59F73C4DEF1C3A6BLL, fetcharray) {
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        if (count <= 0) return (t_fetcharray());
        return (t_fetcharray(params[0]));
      }
      break;
    case 12:
      HASH_GUARD(0x32A58B0CE493957CLL, finalize) {
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD(0x42EDB5CA009D8C6DLL, columntype) {
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        return (t_columntype(params[0]));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3result
Variant c_sqlite3result::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD(0x340A51AE22A924E0LL, reset) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD(0x4C7702FC22784996LL, numcolumns) {
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD(0x696EFC04EE7E47F8LL, columnname) {
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        return (t_columnname(a0));
      }
      break;
    case 11:
      HASH_GUARD(0x59F73C4DEF1C3A6BLL, fetcharray) {
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        if (count <= 0) return (t_fetcharray());
        return (t_fetcharray(a0));
      }
      break;
    case 12:
      HASH_GUARD(0x32A58B0CE493957CLL, finalize) {
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD(0x42EDB5CA009D8C6DLL, columntype) {
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        return (t_columntype(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_sqlite3result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3result
Variant c_sqlite3result::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_sqlite3result
Variant c_sqlite3result::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD(0x340A51AE22A924E0LL, reset) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD(0x4C7702FC22784996LL, numcolumns) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD(0x696EFC04EE7E47F8LL, columnname) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columnname(a0));
      }
      break;
    case 11:
      HASH_GUARD(0x59F73C4DEF1C3A6BLL, fetcharray) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetcharray());
        else return (t_fetcharray(a0));
      }
      break;
    case 12:
      HASH_GUARD(0x32A58B0CE493957CLL, finalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD(0x42EDB5CA009D8C6DLL, columntype) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columntype(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_sqlite3result::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_sqlite3result = {
  c_sqlite3result::os_getInit,
  c_sqlite3result::os_get,
  c_sqlite3result::os_lval,
  c_sqlite3result::os_invoke,
  c_sqlite3result::os_constant,
};
Object co_simplexmlelement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_simplexmlelement)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_simplexmlelement
Variant c_simplexmlelement::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_simplexmlelement
Variant c_simplexmlelement::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_simplexmlelement
Variant &c_simplexmlelement::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_simplexmlelement
void c_simplexmlelement::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_simplexmlelement
Variant c_simplexmlelement::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_simplexmlelement::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_simplexmlelement
Variant c_simplexmlelement::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_simplexmlelement
Variant c_simplexmlelement::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_simplexmlelement
bool c_simplexmlelement::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_simplexmlelement::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_simplexmlelement
bool c_simplexmlelement::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_simplexmlelement
bool c_simplexmlelement::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_simplexmlelement
Variant c_simplexmlelement::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_simplexmlelement::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_simplexmlelement
Variant c_simplexmlelement::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_simplexmlelement
Variant c_simplexmlelement::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_simplexmlelement
Variant& c_simplexmlelement::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_simplexmlelement::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_simplexmlelement
Variant& c_simplexmlelement::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_simplexmlelement
Variant& c_simplexmlelement::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_simplexmlelement
Variant c_simplexmlelement::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_simplexmlelement
IMPLEMENT_CLASS(simplexmlelement)
c_simplexmlelement *c_simplexmlelement::create(String a0, int64 a1, bool a2, String a3, bool a4) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4);
  return this;
}
ObjectData *c_simplexmlelement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 2);
    if (count <= 1) (t___construct(params[0]));
    else if (count == 2) (t___construct(params[0], params[1]));
    else if (count == 3) (t___construct(params[0], params[1], params[2]));
    else if (count == 4) (t___construct(params[0], params[1], params[2], params[3]));
    else (t___construct(params[0], params[1], params[2], params[3], params[4]));
  }
  return this;
}
void c_simplexmlelement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 2);
  if (count <= 1) (t___construct(params[0]));
  else if (count == 2) (t___construct(params[0], params[1]));
  else if (count == 3) (t___construct(params[0], params[1], params[2]));
  else if (count == 4) (t___construct(params[0], params[1], params[2], params[3]));
  else (t___construct(params[0], params[1], params[2], params[3], params[4]));
}
void c_simplexmlelement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
void c_simplexmlelement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_simplexmlelement::cloneImpl() {
  c_simplexmlelement *obj = NEW(c_simplexmlelement)();
  cloneSet(obj);
  return obj;
}
void c_simplexmlelement::cloneSet(c_simplexmlelement *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_simplexmlelement::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelement
Variant c_simplexmlelement::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD(0x3E6BCFB9742FC700LL, offsetexists) {
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        return (t_offsetexists(params[0]));
      }
      break;
    case 3:
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x2DDE12A9866FC794LL, addchild) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        if (count <= 1) return (t_addchild(params[0]));
        if (count == 2) return (t_addchild(params[0], params[1]));
        return (t_addchild(params[0], params[1], params[2]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 22:
      HASH_GUARD(0x52F7AA6C19BEEAD6LL, addattribute) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        if (count <= 1) return (t_addattribute(params[0]), null);
        if (count == 2) return (t_addattribute(params[0], params[1]), null);
        return (t_addattribute(params[0], params[1], params[2]), null);
      }
      break;
    case 24:
      HASH_GUARD(0x61D11ECEF4404498LL, offsetget) {
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        return (t_offsetget(params[0]));
      }
      break;
    case 27:
      HASH_GUARD(0x0817454F196A9A1BLL, xpath) {
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        return (t_xpath(params[0]));
      }
      HASH_GUARD(0x04FB7028C9A2079BLL, __unset) {
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        return (t___unset(params[0]));
      }
      break;
    case 29:
      HASH_GUARD(0x4B65E1A09A33F21DLL, attributes) {
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        if (count <= 0) return (t_attributes());
        if (count == 1) return (t_attributes(params[0]));
        return (t_attributes(params[0], params[1]));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        if (count <= 1) return (t___construct(params[0]), null);
        if (count == 2) return (t___construct(params[0], params[1]), null);
        if (count == 3) return (t___construct(params[0], params[1], params[2]), null);
        if (count == 4) return (t___construct(params[0], params[1], params[2], params[3]), null);
        return (t___construct(params[0], params[1], params[2], params[3], params[4]), null);
      }
      break;
    case 37:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD(0x6D9D75B7E3B40FA6LL, getnamespaces) {
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        if (count <= 0) return (t_getnamespaces());
        return (t_getnamespaces(params[0]));
      }
      HASH_GUARD(0x5C09D9345FD864A6LL, asxml) {
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        if (count <= 0) return (t_asxml());
        return (t_asxml(params[0]));
      }
      break;
    case 45:
      HASH_GUARD(0x2B299E949E2E82ADLL, children) {
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        if (count <= 0) return (t_children());
        if (count == 1) return (t_children(params[0]));
        return (t_children(params[0], params[1]));
      }
      break;
    case 49:
      HASH_GUARD(0x0D08AA5F0B2F34F1LL, getdocnamespaces) {
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        if (count <= 0) return (t_getdocnamespaces());
        return (t_getdocnamespaces(params[0]));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD(0x0957F693A48AF738LL, offsetset) {
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        return (t_offsetset(params[0], params[1]), null);
      }
      break;
    case 58:
      HASH_GUARD(0x08329980E6369ABALL, offsetunset) {
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        return (t_offsetunset(params[0]), null);
      }
      break;
    case 61:
      HASH_GUARD(0x3FE8F6937854F83DLL, registerxpathnamespace) {
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        return (t_registerxpathnamespace(params[0], params[1]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelement
Variant c_simplexmlelement::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD(0x3E6BCFB9742FC700LL, offsetexists) {
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        return (t_offsetexists(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x2DDE12A9866FC794LL, addchild) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        if (count <= 1) return (t_addchild(a0));
        if (count == 2) return (t_addchild(a0, a1));
        return (t_addchild(a0, a1, a2));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD(0x52F7AA6C19BEEAD6LL, addattribute) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        if (count <= 1) return (t_addattribute(a0), null);
        if (count == 2) return (t_addattribute(a0, a1), null);
        return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 24:
      HASH_GUARD(0x61D11ECEF4404498LL, offsetget) {
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        return (t_offsetget(a0));
      }
      break;
    case 27:
      HASH_GUARD(0x0817454F196A9A1BLL, xpath) {
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        return (t_xpath(a0));
      }
      HASH_GUARD(0x04FB7028C9A2079BLL, __unset) {
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        return (t___unset(a0));
      }
      break;
    case 29:
      HASH_GUARD(0x4B65E1A09A33F21DLL, attributes) {
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        if (count <= 0) return (t_attributes());
        if (count == 1) return (t_attributes(a0));
        return (t_attributes(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 37:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD(0x6D9D75B7E3B40FA6LL, getnamespaces) {
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        if (count <= 0) return (t_getnamespaces());
        return (t_getnamespaces(a0));
      }
      HASH_GUARD(0x5C09D9345FD864A6LL, asxml) {
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        if (count <= 0) return (t_asxml());
        return (t_asxml(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x2B299E949E2E82ADLL, children) {
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        if (count <= 0) return (t_children());
        if (count == 1) return (t_children(a0));
        return (t_children(a0, a1));
      }
      break;
    case 49:
      HASH_GUARD(0x0D08AA5F0B2F34F1LL, getdocnamespaces) {
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        if (count <= 0) return (t_getdocnamespaces());
        return (t_getdocnamespaces(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD(0x0957F693A48AF738LL, offsetset) {
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        return (t_offsetset(a0, a1), null);
      }
      break;
    case 58:
      HASH_GUARD(0x08329980E6369ABALL, offsetunset) {
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        return (t_offsetunset(a0), null);
      }
      break;
    case 61:
      HASH_GUARD(0x3FE8F6937854F83DLL, registerxpathnamespace) {
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_simplexmlelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_simplexmlelement
Variant c_simplexmlelement::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_simplexmlelement
Variant c_simplexmlelement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD(0x3E6BCFB9742FC700LL, offsetexists) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetexists(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x570B2E1232A12503LL, getiterator) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x2DDE12A9866FC794LL, addchild) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addchild(a0));
        else if (count == 2) return (t_addchild(a0, a1));
        else return (t_addchild(a0, a1, a2));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD(0x52F7AA6C19BEEAD6LL, addattribute) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addattribute(a0), null);
        else if (count == 2) return (t_addattribute(a0, a1), null);
        else return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 24:
      HASH_GUARD(0x61D11ECEF4404498LL, offsetget) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetget(a0));
      }
      break;
    case 27:
      HASH_GUARD(0x0817454F196A9A1BLL, xpath) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_xpath(a0));
      }
      HASH_GUARD(0x04FB7028C9A2079BLL, __unset) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___unset(a0));
      }
      break;
    case 29:
      HASH_GUARD(0x4B65E1A09A33F21DLL, attributes) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_attributes());
        else if (count == 1) return (t_attributes(a0));
        else return (t_attributes(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 37:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD(0x6D9D75B7E3B40FA6LL, getnamespaces) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getnamespaces());
        else return (t_getnamespaces(a0));
      }
      HASH_GUARD(0x5C09D9345FD864A6LL, asxml) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_asxml());
        else return (t_asxml(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x2B299E949E2E82ADLL, children) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_children());
        else if (count == 1) return (t_children(a0));
        else return (t_children(a0, a1));
      }
      break;
    case 49:
      HASH_GUARD(0x0D08AA5F0B2F34F1LL, getdocnamespaces) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getdocnamespaces());
        else return (t_getdocnamespaces(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD(0x0957F693A48AF738LL, offsetset) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetset(a0, a1), null);
      }
      break;
    case 58:
      HASH_GUARD(0x08329980E6369ABALL, offsetunset) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetunset(a0), null);
      }
      break;
    case 61:
      HASH_GUARD(0x3FE8F6937854F83DLL, registerxpathnamespace) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_simplexmlelement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_simplexmlelement = {
  c_simplexmlelement::os_getInit,
  c_simplexmlelement::os_get,
  c_simplexmlelement::os_lval,
  c_simplexmlelement::os_invoke,
  c_simplexmlelement::os_constant,
};
Object co_domprocessinginstruction(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domprocessinginstruction)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domprocessinginstruction
Variant c_domprocessinginstruction::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domprocessinginstruction
Variant c_domprocessinginstruction::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domprocessinginstruction
Variant &c_domprocessinginstruction::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domprocessinginstruction
void c_domprocessinginstruction::o_get(Array &props) const {
  c_domnode::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_get_domprocessinginstruction
Variant c_domprocessinginstruction::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domprocessinginstruction::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domprocessinginstruction
Variant c_domprocessinginstruction::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domprocessinginstruction
Variant c_domprocessinginstruction::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domprocessinginstruction
bool c_domprocessinginstruction::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domprocessinginstruction::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domprocessinginstruction
bool c_domprocessinginstruction::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domprocessinginstruction
bool c_domprocessinginstruction::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_set_domprocessinginstruction
Variant c_domprocessinginstruction::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domprocessinginstruction::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domprocessinginstruction
Variant c_domprocessinginstruction::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domprocessinginstruction
Variant c_domprocessinginstruction::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domprocessinginstruction
Variant& c_domprocessinginstruction::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domprocessinginstruction::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domprocessinginstruction
Variant& c_domprocessinginstruction::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domprocessinginstruction
Variant& c_domprocessinginstruction::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domprocessinginstruction
Variant c_domprocessinginstruction::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domprocessinginstruction
IMPLEMENT_CLASS(domprocessinginstruction)
c_domprocessinginstruction *c_domprocessinginstruction::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_domprocessinginstruction::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    if (count <= 1) (t___construct(params[0]));
    else (t___construct(params[0], params[1]));
  }
  return this;
}
void c_domprocessinginstruction::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  if (count <= 1) (t___construct(params[0]));
  else (t___construct(params[0], params[1]));
}
void c_domprocessinginstruction::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_domprocessinginstruction::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domprocessinginstruction::cloneImpl() {
  c_domprocessinginstruction *obj = NEW(c_domprocessinginstruction)();
  cloneSet(obj);
  return obj;
}
void c_domprocessinginstruction::cloneSet(c_domprocessinginstruction *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domprocessinginstruction::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domprocessinginstruction
Variant c_domprocessinginstruction::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domprocessinginstruction
Variant c_domprocessinginstruction::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domprocessinginstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domprocessinginstruction
Variant c_domprocessinginstruction::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domprocessinginstruction
Variant c_domprocessinginstruction::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domprocessinginstruction::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domprocessinginstruction = {
  c_domprocessinginstruction::os_getInit,
  c_domprocessinginstruction::os_get,
  c_domprocessinginstruction::os_lval,
  c_domprocessinginstruction::os_invoke,
  c_domprocessinginstruction::os_constant,
};
Object co_concurrentvector(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_concurrentvector)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_concurrentvector
Variant c_concurrentvector::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_concurrentvector
Variant c_concurrentvector::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_concurrentvector
Variant &c_concurrentvector::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_concurrentvector
void c_concurrentvector::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_get_concurrentvector
Variant c_concurrentvector::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_concurrentvector::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_concurrentvector
Variant c_concurrentvector::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_concurrentvector
Variant c_concurrentvector::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_exists_concurrentvector
bool c_concurrentvector::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_concurrentvector::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_concurrentvector
bool c_concurrentvector::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_concurrentvector
bool c_concurrentvector::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_set_concurrentvector
Variant c_concurrentvector::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_concurrentvector::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_concurrentvector
Variant c_concurrentvector::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_concurrentvector
Variant c_concurrentvector::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_lval_concurrentvector
Variant& c_concurrentvector::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_concurrentvector::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_concurrentvector
Variant& c_concurrentvector::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_concurrentvector
Variant& c_concurrentvector::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_concurrentvector
Variant c_concurrentvector::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_concurrentvector
IMPLEMENT_CLASS(concurrentvector)
c_concurrentvector *c_concurrentvector::create(Array a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_concurrentvector::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    if (count <= 0) (t___construct());
    else (t___construct(params[0]));
  }
  return this;
}
void c_concurrentvector::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  if (count <= 0) (t___construct());
  else (t___construct(params[0]));
}
void c_concurrentvector::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
void c_concurrentvector::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_concurrentvector::cloneImpl() {
  c_concurrentvector *obj = NEW(c_concurrentvector)();
  cloneSet(obj);
  return obj;
}
void c_concurrentvector::cloneSet(c_concurrentvector *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_concurrentvector
Variant c_concurrentvector::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD(0x3A88D49C06AF8890LL, size) {
        if (count > 0) return throw_toomany_arguments("size", 0, 1);
        return (t_size());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0E5B3A7FEF8452D3LL, element_at) {
        if (count != 1) return throw_wrong_arguments("element_at", count, 1, 1, 1);
        return (t_element_at(params[0]));
      }
      break;
    case 8:
      HASH_GUARD(0x1C453724CCB144B8LL, as_array) {
        if (count > 0) return throw_toomany_arguments("as_array", 0, 1);
        return (t_as_array());
      }
      HASH_GUARD(0x321E2BF5D878AA38LL, push) {
        if (count != 1) return throw_wrong_arguments("push", count, 1, 1, 1);
        return (t_push(params[0]), null);
      }
      break;
    case 14:
      HASH_GUARD(0x5F79EF9A7F2CF5FELL, set_at) {
        if (count != 2) return throw_wrong_arguments("set_at", count, 2, 2, 1);
        return (t_set_at(params[0], params[1]), null);
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(params[0]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_concurrentvector
Variant c_concurrentvector::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD(0x3A88D49C06AF8890LL, size) {
        if (count > 0) return throw_toomany_arguments("size", 0, 1);
        return (t_size());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0E5B3A7FEF8452D3LL, element_at) {
        if (count != 1) return throw_wrong_arguments("element_at", count, 1, 1, 1);
        return (t_element_at(a0));
      }
      break;
    case 8:
      HASH_GUARD(0x1C453724CCB144B8LL, as_array) {
        if (count > 0) return throw_toomany_arguments("as_array", 0, 1);
        return (t_as_array());
      }
      HASH_GUARD(0x321E2BF5D878AA38LL, push) {
        if (count != 1) return throw_wrong_arguments("push", count, 1, 1, 1);
        return (t_push(a0), null);
      }
      break;
    case 14:
      HASH_GUARD(0x5F79EF9A7F2CF5FELL, set_at) {
        if (count != 2) return throw_wrong_arguments("set_at", count, 2, 2, 1);
        return (t_set_at(a0, a1), null);
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_concurrentvector
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_concurrentvector
Variant c_concurrentvector::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_concurrentvector
Variant c_concurrentvector::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD(0x3A88D49C06AF8890LL, size) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("size", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_size());
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x0E5B3A7FEF8452D3LL, element_at) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("element_at", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_element_at(a0));
      }
      break;
    case 8:
      HASH_GUARD(0x1C453724CCB144B8LL, as_array) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("as_array", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_as_array());
      }
      HASH_GUARD(0x321E2BF5D878AA38LL, push) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("push", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_push(a0), null);
      }
      break;
    case 14:
      HASH_GUARD(0x5F79EF9A7F2CF5FELL, set_at) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("set_at", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_set_at(a0, a1), null);
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_concurrentvector::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_concurrentvector = {
  c_concurrentvector::os_getInit,
  c_concurrentvector::os_get,
  c_concurrentvector::os_lval,
  c_concurrentvector::os_invoke,
  c_concurrentvector::os_constant,
};
Object co_pdostatement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_pdostatement)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdostatement
Variant c_pdostatement::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdostatement
Variant c_pdostatement::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdostatement
Variant &c_pdostatement::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_pdostatement
void c_pdostatement::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_get_pdostatement
Variant c_pdostatement::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_pdostatement::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdostatement
Variant c_pdostatement::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdostatement
Variant c_pdostatement::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_pdostatement
bool c_pdostatement::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_pdostatement::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdostatement
bool c_pdostatement::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdostatement
bool c_pdostatement::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_set_pdostatement
Variant c_pdostatement::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_pdostatement::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdostatement
Variant c_pdostatement::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdostatement
Variant c_pdostatement::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_pdostatement
Variant& c_pdostatement::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_pdostatement::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdostatement
Variant& c_pdostatement::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdostatement
Variant& c_pdostatement::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_pdostatement
Variant c_pdostatement::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_pdostatement
IMPLEMENT_CLASS(pdostatement)
c_pdostatement *c_pdostatement::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_pdostatement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_pdostatement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_pdostatement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_pdostatement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_pdostatement::cloneImpl() {
  c_pdostatement *obj = NEW(c_pdostatement)();
  cloneSet(obj);
  return obj;
}
void c_pdostatement::cloneSet(c_pdostatement *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdostatement
Variant c_pdostatement::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x5740729B65EB8E41LL, fetchall) {
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        if (count <= 0) return (t_fetchall());
        if (count == 1) return (t_fetchall(params[0]));
        if (count == 2) return (t_fetchall(params[0], params[1]));
        return (t_fetchall(params[0], params[1], params[2]));
      }
      break;
    case 3:
      HASH_GUARD(0x436E6AFC3628E403LL, bindvalue) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(params[0], params[1]));
        return (t_bindvalue(params[0], params[1], params[2]));
      }
      break;
    case 5:
      HASH_GUARD(0x75A2E23098C65C05LL, closecursor) {
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD(0x6D0664CC2372F2C7LL, errorcode) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(params[0], params[1]));
      }
      break;
    case 14:
      HASH_GUARD(0x187C7F43EB57714ELL, execute) {
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        if (count <= 0) return (t_execute());
        return (t_execute(params[0]));
      }
      break;
    case 15:
      HASH_GUARD(0x32A381ECDC91918FLL, columncount) {
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        return (t_columncount());
      }
      break;
    case 18:
      HASH_GUARD(0x31A8917EC4F2A252LL, nextrowset) {
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD(0x77B13FCF1BA41696LL, bindparam) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        if (count <= 2) return (t_bindparam(params[0], ref(const_cast<Array&>(params).lvalAt(1))));
        if (count == 3) return (t_bindparam(params[0], ref(const_cast<Array&>(params).lvalAt(1)), params[2]));
        if (count == 4) return (t_bindparam(params[0], ref(const_cast<Array&>(params).lvalAt(1)), params[2], params[3]));
        return (t_bindparam(params[0], ref(const_cast<Array&>(params).lvalAt(1)), params[2], params[3], params[4]));
      }
      break;
    case 25:
      HASH_GUARD(0x5C38814410C5FFD9LL, fetchcolumn) {
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        if (count <= 0) return (t_fetchcolumn());
        return (t_fetchcolumn(params[0]));
      }
      break;
    case 26:
      HASH_GUARD(0x0D43A7148903299ALL, rowcount) {
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD(0x4389F50CAA085CDCLL, __wakeup) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 29:
      HASH_GUARD(0x1C87AD14A095219DLL, bindcolumn) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        if (count <= 2) return (t_bindcolumn(params[0], ref(const_cast<Array&>(params).lvalAt(1))));
        if (count == 3) return (t_bindcolumn(params[0], ref(const_cast<Array&>(params).lvalAt(1)), params[2]));
        if (count == 4) return (t_bindcolumn(params[0], ref(const_cast<Array&>(params).lvalAt(1)), params[2], params[3]));
        return (t_bindcolumn(params[0], ref(const_cast<Array&>(params).lvalAt(1)), params[2], params[3], params[4]));
      }
      HASH_GUARD(0x0E1814AA3327229DLL, fetchobject) {
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        if (count <= 0) return (t_fetchobject());
        if (count == 1) return (t_fetchobject(params[0]));
        return (t_fetchobject(params[0], params[1]));
      }
      break;
    case 30:
      HASH_GUARD(0x1DDD412E7F04605ELL, errorinfo) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x78C9BF8620136861LL, setfetchmode) {
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        if (count <= 1) return (t_setfetchmode(count, params[0]));
        return (t_setfetchmode(count,params[0], params.slice(1, count - 1, false)));
      }
      break;
    case 34:
      HASH_GUARD(0x699F5A1E3BD7B2A2LL, debugdumpparams) {
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(params[0]));
      }
      break;
    case 45:
      HASH_GUARD(0x61D1244DDADBC02DLL, __sleep) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 59:
      HASH_GUARD(0x5B6B980006E717FBLL, getcolumnmeta) {
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        return (t_getcolumnmeta(params[0]));
      }
      HASH_GUARD(0x5E82B850BB90B0FBLL, fetch) {
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        if (count <= 0) return (t_fetch());
        if (count == 1) return (t_fetch(params[0]));
        if (count == 2) return (t_fetch(params[0], params[1]));
        return (t_fetch(params[0], params[1], params[2]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdostatement
Variant c_pdostatement::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x5740729B65EB8E41LL, fetchall) {
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        if (count <= 0) return (t_fetchall());
        if (count == 1) return (t_fetchall(a0));
        if (count == 2) return (t_fetchall(a0, a1));
        return (t_fetchall(a0, a1, a2));
      }
      break;
    case 3:
      HASH_GUARD(0x436E6AFC3628E403LL, bindvalue) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 5:
      HASH_GUARD(0x75A2E23098C65C05LL, closecursor) {
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD(0x6D0664CC2372F2C7LL, errorcode) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD(0x187C7F43EB57714ELL, execute) {
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        if (count <= 0) return (t_execute());
        return (t_execute(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x32A381ECDC91918FLL, columncount) {
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        return (t_columncount());
      }
      break;
    case 18:
      HASH_GUARD(0x31A8917EC4F2A252LL, nextrowset) {
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD(0x77B13FCF1BA41696LL, bindparam) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 25:
      HASH_GUARD(0x5C38814410C5FFD9LL, fetchcolumn) {
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        if (count <= 0) return (t_fetchcolumn());
        return (t_fetchcolumn(a0));
      }
      break;
    case 26:
      HASH_GUARD(0x0D43A7148903299ALL, rowcount) {
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD(0x4389F50CAA085CDCLL, __wakeup) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 29:
      HASH_GUARD(0x1C87AD14A095219DLL, bindcolumn) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      HASH_GUARD(0x0E1814AA3327229DLL, fetchobject) {
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        if (count <= 0) return (t_fetchobject());
        if (count == 1) return (t_fetchobject(a0));
        return (t_fetchobject(a0, a1));
      }
      break;
    case 30:
      HASH_GUARD(0x1DDD412E7F04605ELL, errorinfo) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x78C9BF8620136861LL, setfetchmode) {
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        if (count <= 1) return (t_setfetchmode(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_setfetchmode(count,a0, params));
      }
      break;
    case 34:
      HASH_GUARD(0x699F5A1E3BD7B2A2LL, debugdumpparams) {
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x61D1244DDADBC02DLL, __sleep) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 59:
      HASH_GUARD(0x5B6B980006E717FBLL, getcolumnmeta) {
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        return (t_getcolumnmeta(a0));
      }
      HASH_GUARD(0x5E82B850BB90B0FBLL, fetch) {
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        if (count <= 0) return (t_fetch());
        if (count == 1) return (t_fetch(a0));
        if (count == 2) return (t_fetch(a0, a1));
        return (t_fetch(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdostatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdostatement
Variant c_pdostatement::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdostatement
Variant c_pdostatement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD(0x5740729B65EB8E41LL, fetchall) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchall());
        else if (count == 1) return (t_fetchall(a0));
        else if (count == 2) return (t_fetchall(a0, a1));
        else return (t_fetchall(a0, a1, a2));
      }
      break;
    case 3:
      HASH_GUARD(0x436E6AFC3628E403LL, bindvalue) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 5:
      HASH_GUARD(0x75A2E23098C65C05LL, closecursor) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD(0x6D0664CC2372F2C7LL, errorcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD(0x187C7F43EB57714ELL, execute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_execute());
        else return (t_execute(a0));
      }
      break;
    case 15:
      HASH_GUARD(0x32A381ECDC91918FLL, columncount) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columncount());
      }
      break;
    case 18:
      HASH_GUARD(0x31A8917EC4F2A252LL, nextrowset) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD(0x77B13FCF1BA41696LL, bindparam) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        else if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        else return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 25:
      HASH_GUARD(0x5C38814410C5FFD9LL, fetchcolumn) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchcolumn());
        else return (t_fetchcolumn(a0));
      }
      break;
    case 26:
      HASH_GUARD(0x0D43A7148903299ALL, rowcount) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD(0x4389F50CAA085CDCLL, __wakeup) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      break;
    case 29:
      HASH_GUARD(0x1C87AD14A095219DLL, bindcolumn) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        else if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        else if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        else return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      HASH_GUARD(0x0E1814AA3327229DLL, fetchobject) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchobject());
        else if (count == 1) return (t_fetchobject(a0));
        else return (t_fetchobject(a0, a1));
      }
      break;
    case 30:
      HASH_GUARD(0x1DDD412E7F04605ELL, errorinfo) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x78C9BF8620136861LL, setfetchmode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setfetchmode(count, a0));
        return (t_setfetchmode(count, a0,vargs));
      }
      break;
    case 34:
      HASH_GUARD(0x699F5A1E3BD7B2A2LL, debugdumpparams) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x61D1244DDADBC02DLL, __sleep) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 59:
      HASH_GUARD(0x5B6B980006E717FBLL, getcolumnmeta) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcolumnmeta(a0));
      }
      HASH_GUARD(0x5E82B850BB90B0FBLL, fetch) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetch());
        else if (count == 1) return (t_fetch(a0));
        else if (count == 2) return (t_fetch(a0, a1));
        else return (t_fetch(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_pdostatement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_pdostatement = {
  c_pdostatement::os_getInit,
  c_pdostatement::os_get,
  c_pdostatement::os_lval,
  c_pdostatement::os_invoke,
  c_pdostatement::os_constant,
};
Object co_soapclient(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapclient)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapclient
Variant c_soapclient::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapclient
Variant c_soapclient::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapclient
Variant &c_soapclient::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapclient
void c_soapclient::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapclient
Variant c_soapclient::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_soapclient::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapclient
Variant c_soapclient::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapclient
Variant c_soapclient::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapclient
bool c_soapclient::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_soapclient::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapclient
bool c_soapclient::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapclient
bool c_soapclient::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapclient
Variant c_soapclient::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_soapclient::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapclient
Variant c_soapclient::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapclient
Variant c_soapclient::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapclient
Variant& c_soapclient::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_soapclient::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapclient
Variant& c_soapclient::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapclient
Variant& c_soapclient::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapclient
Variant c_soapclient::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapclient
IMPLEMENT_CLASS(soapclient)
c_soapclient *c_soapclient::create(Variant a0, Array a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_soapclient::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    if (count <= 1) (t___construct(params[0]));
    else (t___construct(params[0], params[1]));
  }
  return this;
}
void c_soapclient::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  if (count <= 1) (t___construct(params[0]));
  else (t___construct(params[0], params[1]));
}
void c_soapclient::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_soapclient::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapclient::cloneImpl() {
  c_soapclient *obj = NEW(c_soapclient)();
  cloneSet(obj);
  return obj;
}
void c_soapclient::cloneSet(c_soapclient *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_soapclient::doCall(Variant v_name, Variant v_arguments, bool fatal) {
  return t___call(v_name, !v_arguments.isNull() ? v_arguments : Variant(Array::Create()));
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapclient
Variant c_soapclient::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD(0x5C5C1E24A140F6E4LL, __getlastrequest) {
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD(0x3648EE7D3B37DE8CLL, __getlastrequestheaders) {
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        return (t___getlastrequestheaders());
      }
      HASH_GUARD(0x5D73364F53CEEB6CLL, __call) {
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        return (t___call(params[0], params[1]));
      }
      break;
    case 17:
      HASH_GUARD(0x1365B3105FC59871LL, __getfunctions) {
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x3CA9145031035A54LL, __getlastresponse) {
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD(0x19A26CEC7E8AAEF5LL, __dorequest) {
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        if (count <= 4) return (t___dorequest(params[0], params[1], params[2], params[3]));
        return (t___dorequest(params[0], params[1], params[2], params[3], params[4]));
      }
      HASH_GUARD(0x52C6ABACCBFD0C75LL, __setcookie) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        if (count <= 1) return (t___setcookie(params[0]));
        return (t___setcookie(params[0], params[1]));
      }
      HASH_GUARD(0x628D398E7604B9D5LL, __gettypes) {
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD(0x4A2F89F662050D99LL, __soapcall) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        if (count <= 2) return (t___soapcall(params[0], params[1]));
        if (count == 3) return (t___soapcall(params[0], params[1], params[2]));
        if (count == 4) return (t___soapcall(params[0], params[1], params[2], params[3]));
        return (t___soapcall(params[0], params[1], params[2], params[3], ref(const_cast<Array&>(params).lvalAt(4))));
      }
      break;
    case 26:
      HASH_GUARD(0x0C94657A58A82CFALL, __getlastresponseheaders) {
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD(0x14842228D5E335BBLL, __setsoapheaders) {
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        if (count <= 0) return (t___setsoapheaders());
        return (t___setsoapheaders(params[0]));
      }
      break;
    case 31:
      HASH_GUARD(0x232D13904DBC36FFLL, __setlocation) {
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        if (count <= 0) return (t___setlocation());
        return (t___setlocation(params[0]));
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapclient
Variant c_soapclient::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD(0x5C5C1E24A140F6E4LL, __getlastrequest) {
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD(0x3648EE7D3B37DE8CLL, __getlastrequestheaders) {
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        return (t___getlastrequestheaders());
      }
      HASH_GUARD(0x5D73364F53CEEB6CLL, __call) {
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        return (t___call(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD(0x1365B3105FC59871LL, __getfunctions) {
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x3CA9145031035A54LL, __getlastresponse) {
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD(0x19A26CEC7E8AAEF5LL, __dorequest) {
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        return (t___dorequest(a0, a1, a2, a3, a4));
      }
      HASH_GUARD(0x52C6ABACCBFD0C75LL, __setcookie) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        if (count <= 1) return (t___setcookie(a0));
        return (t___setcookie(a0, a1));
      }
      HASH_GUARD(0x628D398E7604B9D5LL, __gettypes) {
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD(0x4A2F89F662050D99LL, __soapcall) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        if (count <= 2) return (t___soapcall(a0, a1));
        if (count == 3) return (t___soapcall(a0, a1, a2));
        if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 26:
      HASH_GUARD(0x0C94657A58A82CFALL, __getlastresponseheaders) {
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD(0x14842228D5E335BBLL, __setsoapheaders) {
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        if (count <= 0) return (t___setsoapheaders());
        return (t___setsoapheaders(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x232D13904DBC36FFLL, __setlocation) {
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        if (count <= 0) return (t___setlocation());
        return (t___setlocation(a0));
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapclient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapclient
Variant c_soapclient::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapclient
Variant c_soapclient::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD(0x5C5C1E24A140F6E4LL, __getlastrequest) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD(0x3648EE7D3B37DE8CLL, __getlastrequestheaders) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequestheaders());
      }
      HASH_GUARD(0x5D73364F53CEEB6CLL, __call) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___call(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD(0x1365B3105FC59871LL, __getfunctions) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x3CA9145031035A54LL, __getlastresponse) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD(0x19A26CEC7E8AAEF5LL, __dorequest) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        else return (t___dorequest(a0, a1, a2, a3, a4));
      }
      HASH_GUARD(0x52C6ABACCBFD0C75LL, __setcookie) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___setcookie(a0));
        else return (t___setcookie(a0, a1));
      }
      HASH_GUARD(0x628D398E7604B9D5LL, __gettypes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD(0x4A2F89F662050D99LL, __soapcall) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___soapcall(a0, a1));
        else if (count == 3) return (t___soapcall(a0, a1, a2));
        else if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        else return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 26:
      HASH_GUARD(0x0C94657A58A82CFALL, __getlastresponseheaders) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD(0x14842228D5E335BBLL, __setsoapheaders) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setsoapheaders());
        else return (t___setsoapheaders(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x232D13904DBC36FFLL, __setlocation) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setlocation());
        else return (t___setlocation(a0));
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapclient::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapclient = {
  c_soapclient::os_getInit,
  c_soapclient::os_get,
  c_soapclient::os_lval,
  c_soapclient::os_invoke,
  c_soapclient::os_constant,
};
Object co_soapparam(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapparam)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapparam
Variant c_soapparam::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapparam
Variant c_soapparam::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapparam
Variant &c_soapparam::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapparam
void c_soapparam::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapparam
Variant c_soapparam::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_soapparam::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapparam
Variant c_soapparam::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapparam
Variant c_soapparam::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapparam
bool c_soapparam::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_soapparam::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapparam
bool c_soapparam::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapparam
bool c_soapparam::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapparam
Variant c_soapparam::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_soapparam::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapparam
Variant c_soapparam::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapparam
Variant c_soapparam::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapparam
Variant& c_soapparam::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_soapparam::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapparam
Variant& c_soapparam::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapparam
Variant& c_soapparam::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapparam
Variant c_soapparam::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapparam
IMPLEMENT_CLASS(soapparam)
c_soapparam *c_soapparam::create(Variant a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_soapparam::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
    (t___construct(params[0], params[1]));
  }
  return this;
}
void c_soapparam::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
  (t___construct(params[0], params[1]));
}
void c_soapparam::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
void c_soapparam::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapparam::cloneImpl() {
  c_soapparam *obj = NEW(c_soapparam)();
  cloneSet(obj);
  return obj;
}
void c_soapparam::cloneSet(c_soapparam *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapparam
Variant c_soapparam::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapparam
Variant c_soapparam::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapparam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapparam
Variant c_soapparam::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapparam
Variant c_soapparam::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapparam::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapparam = {
  c_soapparam::os_getInit,
  c_soapparam::os_get,
  c_soapparam::os_lval,
  c_soapparam::os_invoke,
  c_soapparam::os_constant,
};
Object co_datetime(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_datetime)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_datetime
Variant c_datetime::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_datetime
Variant c_datetime::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_datetime
Variant &c_datetime::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_datetime
void c_datetime::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_get_datetime
Variant c_datetime::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_datetime::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_datetime
Variant c_datetime::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_datetime
Variant c_datetime::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_exists_datetime
bool c_datetime::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_datetime::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_datetime
bool c_datetime::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_datetime
bool c_datetime::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_set_datetime
Variant c_datetime::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_datetime::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_datetime
Variant c_datetime::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_datetime
Variant c_datetime::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_lval_datetime
Variant& c_datetime::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_datetime::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_datetime
Variant& c_datetime::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_datetime
Variant& c_datetime::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_datetime
Variant c_datetime::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 1:
      HASH_RETURN(0x412464A6CC237B01LL, q_datetime_RFC1123, RFC1123);
      break;
    case 2:
      HASH_RETURN(0x2C6387A208554822LL, q_datetime_RFC822, RFC822);
      break;
    case 4:
      HASH_RETURN(0x04BF32CDEC57FF44LL, q_datetime_RFC2822, RFC2822);
      HASH_RETURN(0x65F665B8975C4C44LL, q_datetime_RSS, RSS);
      break;
    case 5:
      HASH_RETURN(0x4C70260A54584B05LL, q_datetime_ATOM, ATOM);
      break;
    case 12:
      HASH_RETURN(0x2183317DB64F7D2CLL, q_datetime_COOKIE, COOKIE);
      break;
    case 16:
      HASH_RETURN(0x5D2FBC8B1577ACB0LL, q_datetime_W3C, W3C);
      break;
    case 17:
      HASH_RETURN(0x66C93EBB188AAF11LL, q_datetime_RFC1036, RFC1036);
      break;
    case 18:
      HASH_RETURN(0x1AE03F7E0EC93DD2LL, q_datetime_RFC850, RFC850);
      break;
    case 25:
      HASH_RETURN(0x337AB8FC3E0FAF79LL, q_datetime_RFC3339, RFC3339);
      break;
    case 27:
      HASH_RETURN(0x6D8D5D3FBA39037BLL, q_datetime_ISO8601, ISO8601);
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_datetime
IMPLEMENT_CLASS(datetime)
c_datetime *c_datetime::create(String a0, Object a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_datetime::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    if (count <= 0) (t___construct());
    else if (count == 1) (t___construct(params[0]));
    else (t___construct(params[0], params[1]));
  }
  return this;
}
void c_datetime::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  if (count <= 0) (t___construct());
  else if (count == 1) (t___construct(params[0]));
  else (t___construct(params[0], params[1]));
}
void c_datetime::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_datetime::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_datetime::cloneImpl() {
  c_datetime *obj = NEW(c_datetime)();
  cloneSet(obj);
  return obj;
}
void c_datetime::cloneSet(c_datetime *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_datetime
Variant c_datetime::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD(0x65A9B2950F080587LL, modify) {
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        return (t_modify(params[0]));
      }
      break;
    case 11:
      HASH_GUARD(0x67314943DC9D120BLL, setdate) {
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        return (t_setdate(params[0], params[1], params[2]));
      }
      HASH_GUARD(0x68DB66F60B55BD0BLL, getoffset) {
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD(0x688601F33BE7716CLL, gettimezone) {
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x16D6DBFD6EE55A74LL, setisodate) {
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        if (count <= 2) return (t_setisodate(params[0], params[1]));
        return (t_setisodate(params[0], params[1], params[2]));
      }
      break;
    case 24:
      HASH_GUARD(0x07CB96AB34F4C258LL, settime) {
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        if (count <= 2) return (t_settime(params[0], params[1]));
        return (t_settime(params[0], params[1], params[2]));
      }
      HASH_GUARD(0x3B576E558B957CB8LL, settimezone) {
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        return (t_settimezone(params[0]));
      }
      break;
    case 27:
      HASH_GUARD(0x1B6DDAF6AAF8CA9BLL, format) {
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        return (t_format(params[0]));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_datetime
Variant c_datetime::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD(0x65A9B2950F080587LL, modify) {
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        return (t_modify(a0));
      }
      break;
    case 11:
      HASH_GUARD(0x67314943DC9D120BLL, setdate) {
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        return (t_setdate(a0, a1, a2));
      }
      HASH_GUARD(0x68DB66F60B55BD0BLL, getoffset) {
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD(0x688601F33BE7716CLL, gettimezone) {
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x16D6DBFD6EE55A74LL, setisodate) {
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        if (count <= 2) return (t_setisodate(a0, a1));
        return (t_setisodate(a0, a1, a2));
      }
      break;
    case 24:
      HASH_GUARD(0x07CB96AB34F4C258LL, settime) {
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        if (count <= 2) return (t_settime(a0, a1));
        return (t_settime(a0, a1, a2));
      }
      HASH_GUARD(0x3B576E558B957CB8LL, settimezone) {
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        return (t_settimezone(a0));
      }
      break;
    case 27:
      HASH_GUARD(0x1B6DDAF6AAF8CA9BLL, format) {
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        return (t_format(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_datetime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_datetime
Variant c_datetime::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_datetime
Variant c_datetime::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD(0x65A9B2950F080587LL, modify) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_modify(a0));
      }
      break;
    case 11:
      HASH_GUARD(0x67314943DC9D120BLL, setdate) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setdate(a0, a1, a2));
      }
      HASH_GUARD(0x68DB66F60B55BD0BLL, getoffset) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD(0x688601F33BE7716CLL, gettimezone) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x16D6DBFD6EE55A74LL, setisodate) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_setisodate(a0, a1));
        else return (t_setisodate(a0, a1, a2));
      }
      break;
    case 24:
      HASH_GUARD(0x07CB96AB34F4C258LL, settime) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_settime(a0, a1));
        else return (t_settime(a0, a1, a2));
      }
      HASH_GUARD(0x3B576E558B957CB8LL, settimezone) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_settimezone(a0));
      }
      break;
    case 27:
      HASH_GUARD(0x1B6DDAF6AAF8CA9BLL, format) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_format(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_datetime::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_datetime = {
  c_datetime::os_getInit,
  c_datetime::os_get,
  c_datetime::os_lval,
  c_datetime::os_invoke,
  c_datetime::os_constant,
};
Object co_pdo(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_pdo)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdo
Variant c_pdo::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdo
Variant c_pdo::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdo
Variant &c_pdo::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_pdo
void c_pdo::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_get_pdo
Variant c_pdo::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_pdo::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdo
Variant c_pdo::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdo
Variant c_pdo::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_pdo
bool c_pdo::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_pdo::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdo
bool c_pdo::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdo
bool c_pdo::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_set_pdo
Variant c_pdo::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_pdo::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdo
Variant c_pdo::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdo
Variant c_pdo::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_pdo
Variant& c_pdo::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_pdo::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdo
Variant& c_pdo::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdo
Variant& c_pdo::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_pdo
Variant c_pdo::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 0:
      HASH_RETURN(0x1800ED92A8884D00LL, q_pdo_ATTR_CASE, ATTR_CASE);
      break;
    case 3:
      HASH_RETURN(0x6E9B4E4F4B5C3103LL, q_pdo_ATTR_FETCH_TABLE_NAMES, ATTR_FETCH_TABLE_NAMES);
      break;
    case 4:
      HASH_RETURN(0x0229D662F91D9C04LL, q_pdo_ERRMODE_EXCEPTION, ERRMODE_EXCEPTION);
      break;
    case 9:
      HASH_RETURN(0x1BFFF5F5DCB18409LL, q_pdo_FETCH_CLASS, FETCH_CLASS);
      break;
    case 17:
      HASH_RETURN(0x5FAD218776C6E511LL, q_pdo_FETCH_INTO, FETCH_INTO);
      break;
    case 19:
      HASH_RETURN(0x6A20B878354ECF13LL, q_pdo_FETCH_UNIQUE, FETCH_UNIQUE);
      break;
    case 21:
      HASH_RETURN(0x7DC6BA9522C1D915LL, q_pdo_PARAM_EVT_FREE, PARAM_EVT_FREE);
      break;
    case 24:
      HASH_RETURN(0x19D6A97EBF5C9F18LL, q_pdo_MYSQL_ATTR_FOUND_ROWS, MYSQL_ATTR_FOUND_ROWS);
      break;
    case 25:
      HASH_RETURN(0x78CB81320C710019LL, q_pdo_FETCH_BOUND, FETCH_BOUND);
      break;
    case 27:
      HASH_RETURN(0x3158D52C3626FE1BLL, q_pdo_MYSQL_ATTR_INIT_COMMAND, MYSQL_ATTR_INIT_COMMAND);
      break;
    case 28:
      HASH_RETURN(0x09507239A4DB181CLL, q_pdo_MYSQL_ATTR_READ_DEFAULT_FILE, MYSQL_ATTR_READ_DEFAULT_FILE);
      break;
    case 29:
      HASH_RETURN(0x2BE16C4111A7B41DLL, q_pdo_ATTR_FETCH_CATALOG_NAMES, ATTR_FETCH_CATALOG_NAMES);
      break;
    case 30:
      HASH_RETURN(0x35E4A4517D06991ELL, q_pdo_ATTR_AUTOCOMMIT, ATTR_AUTOCOMMIT);
      HASH_RETURN(0x2A5BA04D0219F11ELL, q_pdo_CASE_LOWER, CASE_LOWER);
      break;
    case 32:
      HASH_RETURN(0x5E1CA6A41988CA20LL, q_pdo_PARAM_EVT_ALLOC, PARAM_EVT_ALLOC);
      break;
    case 33:
      HASH_RETURN(0x446CC62B738BF121LL, q_pdo_PARAM_INPUT_OUTPUT, PARAM_INPUT_OUTPUT);
      break;
    case 37:
      HASH_RETURN(0x37F650C462FA6A25LL, q_pdo_CASE_UPPER, CASE_UPPER);
      break;
    case 50:
      HASH_RETURN(0x637AFC01C3161B32LL, q_pdo_CASE_NATURAL, CASE_NATURAL);
      break;
    case 52:
      HASH_RETURN(0x6207F7623E381534LL, q_pdo_FETCH_OBJ, FETCH_OBJ);
      HASH_RETURN(0x5149E62B579CE434LL, q_pdo_NULL_TO_STRING, NULL_TO_STRING);
      break;
    case 53:
      HASH_RETURN(0x06AE1A18C18A2435LL, q_pdo_ERRMODE_SILENT, ERRMODE_SILENT);
      break;
    case 59:
      HASH_RETURN(0x01B17428BEE1243BLL, q_pdo_PARAM_EVT_EXEC_PRE, PARAM_EVT_EXEC_PRE);
      break;
    case 69:
      HASH_RETURN(0x7E9A401656942845LL, q_pdo_PARAM_EVT_FETCH_POST, PARAM_EVT_FETCH_POST);
      HASH_RETURN(0x657870F48CF65845LL, q_pdo_FETCH_KEY_PAIR, FETCH_KEY_PAIR);
      break;
    case 82:
      HASH_RETURN(0x58A833E2336D6152LL, q_pdo_ATTR_SERVER_INFO, ATTR_SERVER_INFO);
      break;
    case 86:
      HASH_RETURN(0x57B75F4773C81556LL, q_pdo_PARAM_EVT_NORMALIZE, PARAM_EVT_NORMALIZE);
      break;
    case 89:
      HASH_RETURN(0x73BE6AC0CF87A559LL, q_pdo_MYSQL_ATTR_USE_BUFFERED_QUERY, MYSQL_ATTR_USE_BUFFERED_QUERY);
      break;
    case 90:
      HASH_RETURN(0x17ADF3554B7E785ALL, q_pdo_PARAM_INT, PARAM_INT);
      HASH_RETURN(0x3D6618A0C108385ALL, q_pdo_ATTR_TIMEOUT, ATTR_TIMEOUT);
      break;
    case 91:
      HASH_RETURN(0x5495020CF262F15BLL, q_pdo_ATTR_CONNECTION_STATUS, ATTR_CONNECTION_STATUS);
      HASH_RETURN(0x37888F551D84275BLL, q_pdo_ATTR_ORACLE_NULLS, ATTR_ORACLE_NULLS);
      break;
    case 101:
      HASH_RETURN(0x15A3522970265465LL, q_pdo_FETCH_ORI_NEXT, FETCH_ORI_NEXT);
      break;
    case 111:
      HASH_RETURN(0x350E9275757FD66FLL, q_pdo_FETCH_ORI_REL, FETCH_ORI_REL);
      break;
    case 112:
      HASH_RETURN(0x6870D9DE66F53D70LL, q_pdo_FETCH_ASSOC, FETCH_ASSOC);
      break;
    case 113:
      HASH_RETURN(0x713C8339790FC071LL, q_pdo_ATTR_CURSOR_NAME, ATTR_CURSOR_NAME);
      HASH_RETURN(0x3E1131E6D1D8AA71LL, q_pdo_CURSOR_FWDONLY, CURSOR_FWDONLY);
      break;
    case 121:
      HASH_RETURN(0x630122BA9EC73379LL, q_pdo_PARAM_NULL, PARAM_NULL);
      break;
    case 125:
      HASH_RETURN(0x500C039681530C7DLL, q_pdo_PARAM_BOOL, PARAM_BOOL);
      HASH_RETURN(0x6F1E0122C7478D7DLL, q_pdo_FETCH_GROUP, FETCH_GROUP);
      break;
    case 130:
      HASH_RETURN(0x127EC2B063DABE82LL, q_pdo_FETCH_ORI_FIRST, FETCH_ORI_FIRST);
      HASH_RETURN(0x56FE444CDF05E982LL, q_pdo_FETCH_ORI_LAST, FETCH_ORI_LAST);
      break;
    case 131:
      HASH_RETURN(0x2FF8D931EF724783LL, q_pdo_NULL_EMPTY_STRING, NULL_EMPTY_STRING);
      break;
    case 132:
      HASH_RETURN(0x2011B5A528047784LL, q_pdo_FETCH_NUM, FETCH_NUM);
      break;
    case 133:
      HASH_RETURN(0x5451E44C627DD885LL, q_pdo_FETCH_ORI_PRIOR, FETCH_ORI_PRIOR);
      break;
    case 134:
      HASH_RETURN(0x1B8BA5EEAABDB786LL, q_pdo_PARAM_EVT_EXEC_POST, PARAM_EVT_EXEC_POST);
      break;
    case 135:
      HASH_RETURN(0x04884F5BF712B887LL, q_pdo_NULL_NATURAL, NULL_NATURAL);
      break;
    case 136:
      HASH_RETURN(0x7E64209D5A925F88LL, q_pdo_PARAM_STR, PARAM_STR);
      break;
    case 138:
      HASH_RETURN(0x45AB9806DE20EA8ALL, q_pdo_ATTR_CURSOR, ATTR_CURSOR);
      break;
    case 141:
      HASH_RETURN(0x0EDB017494A91E8DLL, q_pdo_ATTR_DRIVER_NAME, ATTR_DRIVER_NAME);
      break;
    case 142:
      HASH_RETURN(0x126B3038F3345A8ELL, q_pdo_FETCH_USE_DEFAULT, FETCH_USE_DEFAULT);
      break;
    case 143:
      HASH_RETURN(0x2CB5A19FEC8FA78FLL, q_pdo_MYSQL_ATTR_LOCAL_INFILE, MYSQL_ATTR_LOCAL_INFILE);
      break;
    case 150:
      HASH_RETURN(0x25BE9238386D2796LL, q_pdo_FETCH_PROPS_LATE, FETCH_PROPS_LATE);
      break;
    case 153:
      HASH_RETURN(0x18B801DE8D8C9099LL, q_pdo_FETCH_CLASSTYPE, FETCH_CLASSTYPE);
      break;
    case 156:
      HASH_RETURN(0x1EC178DF86F5FD9CLL, q_pdo_FETCH_SERIALIZE, FETCH_SERIALIZE);
      HASH_RETURN(0x6F59434F53EAA49CLL, q_pdo_FETCH_NAMED, FETCH_NAMED);
      break;
    case 159:
      HASH_RETURN(0x474CD607A006A29FLL, q_pdo_ATTR_MAX_COLUMN_LEN, ATTR_MAX_COLUMN_LEN);
      break;
    case 160:
      HASH_RETURN(0x69E26A2377B2B9A0LL, q_pdo_MYSQL_ATTR_DIRECT_QUERY, MYSQL_ATTR_DIRECT_QUERY);
      break;
    case 164:
      HASH_RETURN(0x6851B7545234FCA4LL, q_pdo_PARAM_EVT_FETCH_PRE, PARAM_EVT_FETCH_PRE);
      break;
    case 172:
      HASH_RETURN(0x0EE2F6DF09C510ACLL, q_pdo_PARAM_LOB, PARAM_LOB);
      break;
    case 180:
      HASH_RETURN(0x56D59339A0F5D8B4LL, q_pdo_ATTR_PERSISTENT, ATTR_PERSISTENT);
      break;
    case 183:
      HASH_RETURN(0x614844E1207D8AB7LL, q_pdo_MYSQL_ATTR_READ_DEFAULT_GROUP, MYSQL_ATTR_READ_DEFAULT_GROUP);
      break;
    case 189:
      HASH_RETURN(0x79F5D97C38A185BDLL, q_pdo_ATTR_PREFETCH, ATTR_PREFETCH);
      break;
    case 191:
      HASH_RETURN(0x3DE88E8D8A88F8BFLL, q_pdo_FETCH_COLUMN, FETCH_COLUMN);
      break;
    case 195:
      HASH_RETURN(0x1190A4D4819B0FC3LL, q_pdo_CURSOR_SCROLL, CURSOR_SCROLL);
      break;
    case 197:
      HASH_RETURN(0x60CE39F6493219C5LL, q_pdo_ATTR_STRINGIFY_FETCHES, ATTR_STRINGIFY_FETCHES);
      break;
    case 200:
      HASH_RETURN(0x30D00303975D98C8LL, q_pdo_FETCH_FUNC, FETCH_FUNC);
      HASH_RETURN(0x47D4494BE4FB26C8LL, q_pdo_FETCH_ORI_ABS, FETCH_ORI_ABS);
      break;
    case 203:
      HASH_RETURN(0x73FAA1AA068D19CBLL, q_pdo_MYSQL_ATTR_MAX_BUFFER_SIZE, MYSQL_ATTR_MAX_BUFFER_SIZE);
      break;
    case 209:
      HASH_RETURN(0x5C75BB222F23C4D1LL, q_pdo_FETCH_LAZY, FETCH_LAZY);
      break;
    case 211:
      HASH_RETURN(0x433266B40B47D5D3LL, q_pdo_ATTR_DEFAULT_FETCH_MODE, ATTR_DEFAULT_FETCH_MODE);
      HASH_RETURN(0x57F9152D7EC3A5D3LL, q_pdo_MYSQL_ATTR_COMPRESS, MYSQL_ATTR_COMPRESS);
      break;
    case 214:
      HASH_RETURN(0x4ECCFDA6800707D6LL, q_pdo_ATTR_ERRMODE, ATTR_ERRMODE);
      HASH_RETURN(0x778CAF375C746FD6LL, q_pdo_ATTR_SERVER_VERSION, ATTR_SERVER_VERSION);
      break;
    case 219:
      HASH_RETURN(0x50691422A1041FDBLL, q_pdo_FETCH_BOTH, FETCH_BOTH);
      break;
    case 220:
      HASH_RETURN(0x4D1DDF7F772D54DCLL, q_pdo_ERRMODE_WARNING, ERRMODE_WARNING);
      break;
    case 228:
      HASH_RETURN(0x167DA94C576B87E4LL, q_pdo_ATTR_EMULATE_PREPARES, ATTR_EMULATE_PREPARES);
      break;
    case 235:
      HASH_RETURN(0x2F4E578043D848EBLL, q_pdo_ATTR_STATEMENT_CLASS, ATTR_STATEMENT_CLASS);
      break;
    case 245:
      HASH_RETURN(0x5C3BFDBB53386FF5LL, q_pdo_ATTR_CLIENT_VERSION, ATTR_CLIENT_VERSION);
      HASH_RETURN(0x16017F3F58821EF5LL, q_pdo_ERR_NONE, ERR_NONE);
      break;
    case 251:
      HASH_RETURN(0x13EC16B8F7B7B1FBLL, q_pdo_MYSQL_ATTR_IGNORE_SPACE, MYSQL_ATTR_IGNORE_SPACE);
      break;
    case 253:
      HASH_RETURN(0x51938FCA0AE927FDLL, q_pdo_PARAM_STMT, PARAM_STMT);
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_pdo
IMPLEMENT_CLASS(pdo)
c_pdo *c_pdo::create(String a0, String a1, String a2, Array a3) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3);
  return this;
}
ObjectData *c_pdo::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 2);
    if (count <= 1) (t___construct(params[0]));
    else if (count == 2) (t___construct(params[0], params[1]));
    else if (count == 3) (t___construct(params[0], params[1], params[2]));
    else (t___construct(params[0], params[1], params[2], params[3]));
  }
  return this;
}
void c_pdo::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 2);
  if (count <= 1) (t___construct(params[0]));
  else if (count == 2) (t___construct(params[0], params[1]));
  else if (count == 3) (t___construct(params[0], params[1], params[2]));
  else (t___construct(params[0], params[1], params[2], params[3]));
}
void c_pdo::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else (t___construct(a0, a1, a2, a3), null);
}
void c_pdo::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_pdo::cloneImpl() {
  c_pdo *obj = NEW(c_pdo)();
  cloneSet(obj);
  return obj;
}
void c_pdo::cloneSet(c_pdo *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdo
Variant c_pdo::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD(0x6D0664CC2372F2C7LL, errorcode) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(params[0], params[1]));
      }
      break;
    case 12:
      HASH_GUARD(0x4F1D1ED7B087208CLL, exec) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(params[0]));
      }
      break;
    case 14:
      HASH_GUARD(0x7FF4D594AC38340ELL, getavailabledrivers) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD(0x25466EABBA2D7C12LL, lastinsertid) {
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        if (count <= 0) return (t_lastinsertid());
        return (t_lastinsertid(params[0]));
      }
      break;
    case 28:
      HASH_GUARD(0x4389F50CAA085CDCLL, __wakeup) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD(0x1DDD412E7F04605ELL, errorinfo) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        if (count <= 1) return (t___construct(params[0]), null);
        if (count == 2) return (t___construct(params[0], params[1]), null);
        if (count == 3) return (t___construct(params[0], params[1], params[2]), null);
        return (t___construct(params[0], params[1], params[2], params[3]), null);
      }
      break;
    case 36:
      HASH_GUARD(0x24D23BE465E3F324LL, commit) {
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(params[0]));
      }
      break;
    case 45:
      HASH_GUARD(0x61D1244DDADBC02DLL, __sleep) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD(0x1740B14E849464EELL, quote) {
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        if (count <= 1) return (t_quote(params[0]));
        return (t_quote(params[0], params[1]));
      }
      break;
    case 47:
      HASH_GUARD(0x540020AE4BA591AFLL, prepare) {
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        if (count <= 1) return (t_prepare(params[0]));
        return (t_prepare(params[0], params[1]));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD(0x374B46BC6D79EC36LL, rollback) {
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(params[0]));
      }
      break;
    case 59:
      HASH_GUARD(0x0DE392135C33E23BLL, begintransaction) {
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_pdo
Variant c_pdo::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD(0x6D0664CC2372F2C7LL, errorcode) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 12:
      HASH_GUARD(0x4F1D1ED7B087208CLL, exec) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 14:
      HASH_GUARD(0x7FF4D594AC38340ELL, getavailabledrivers) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD(0x25466EABBA2D7C12LL, lastinsertid) {
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        if (count <= 0) return (t_lastinsertid());
        return (t_lastinsertid(a0));
      }
      break;
    case 28:
      HASH_GUARD(0x4389F50CAA085CDCLL, __wakeup) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD(0x1DDD412E7F04605ELL, errorinfo) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 36:
      HASH_GUARD(0x24D23BE465E3F324LL, commit) {
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x61D1244DDADBC02DLL, __sleep) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD(0x1740B14E849464EELL, quote) {
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        if (count <= 1) return (t_quote(a0));
        return (t_quote(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD(0x540020AE4BA591AFLL, prepare) {
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        if (count <= 1) return (t_prepare(a0));
        return (t_prepare(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD(0x374B46BC6D79EC36LL, rollback) {
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    case 59:
      HASH_GUARD(0x0DE392135C33E23BLL, begintransaction) {
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_pdo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdo
Variant c_pdo::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x7FF4D594AC38340ELL, getavailabledrivers) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_pdo
Variant c_pdo::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD(0x6D0664CC2372F2C7LL, errorcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 12:
      HASH_GUARD(0x4F1D1ED7B087208CLL, exec) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 14:
      HASH_GUARD(0x7FF4D594AC38340ELL, getavailabledrivers) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD(0x25466EABBA2D7C12LL, lastinsertid) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_lastinsertid());
        else return (t_lastinsertid(a0));
      }
      break;
    case 28:
      HASH_GUARD(0x4389F50CAA085CDCLL, __wakeup) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD(0x1DDD412E7F04605ELL, errorinfo) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 36:
      HASH_GUARD(0x24D23BE465E3F324LL, commit) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD(0x61D1244DDADBC02DLL, __sleep) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD(0x1740B14E849464EELL, quote) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_quote(a0));
        else return (t_quote(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD(0x540020AE4BA591AFLL, prepare) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_prepare(a0));
        else return (t_prepare(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD(0x374B46BC6D79EC36LL, rollback) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    case 59:
      HASH_GUARD(0x0DE392135C33E23BLL, begintransaction) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_pdo::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x7FF4D594AC38340ELL, getavailabledrivers) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_pdo = {
  c_pdo::os_getInit,
  c_pdo::os_get,
  c_pdo::os_lval,
  c_pdo::os_invoke,
  c_pdo::os_constant,
};
Object co_domentity(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domentity)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domentity
Variant c_domentity::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domentity
Variant c_domentity::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domentity
Variant &c_domentity::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domentity
void c_domentity::o_get(Array &props) const {
  c_domnode::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_get_domentity
Variant c_domentity::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domentity::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domentity
Variant c_domentity::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domentity
Variant c_domentity::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domentity
bool c_domentity::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domentity::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domentity
bool c_domentity::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domentity
bool c_domentity::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_set_domentity
Variant c_domentity::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domentity::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domentity
Variant c_domentity::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domentity
Variant c_domentity::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domentity
Variant& c_domentity::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domentity::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domentity
Variant& c_domentity::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domentity
Variant& c_domentity::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domentity
Variant c_domentity::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domentity
IMPLEMENT_CLASS(domentity)
c_domentity *c_domentity::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domentity::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domentity::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domentity::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domentity::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domentity::cloneImpl() {
  c_domentity *obj = NEW(c_domentity)();
  cloneSet(obj);
  return obj;
}
void c_domentity::cloneSet(c_domentity *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domentity::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domentity
Variant c_domentity::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domentity
Variant c_domentity::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domentity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domentity
Variant c_domentity::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domentity
Variant c_domentity::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domentity::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domentity = {
  c_domentity::os_getInit,
  c_domentity::os_get,
  c_domentity::os_lval,
  c_domentity::os_invoke,
  c_domentity::os_constant,
};
Object co_xmlwriter(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_xmlwriter)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_xmlwriter
Variant c_xmlwriter::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_xmlwriter
Variant c_xmlwriter::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_xmlwriter
Variant &c_xmlwriter::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_xmlwriter
void c_xmlwriter::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_get_xmlwriter
Variant c_xmlwriter::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_xmlwriter::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_xmlwriter
Variant c_xmlwriter::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_xmlwriter
Variant c_xmlwriter::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_exists_xmlwriter
bool c_xmlwriter::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_xmlwriter::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_xmlwriter
bool c_xmlwriter::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_xmlwriter
bool c_xmlwriter::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_set_xmlwriter
Variant c_xmlwriter::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_xmlwriter::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_xmlwriter
Variant c_xmlwriter::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_xmlwriter
Variant c_xmlwriter::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_lval_xmlwriter
Variant& c_xmlwriter::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_xmlwriter::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_xmlwriter
Variant& c_xmlwriter::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_xmlwriter
Variant& c_xmlwriter::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_xmlwriter
Variant c_xmlwriter::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_xmlwriter
IMPLEMENT_CLASS(xmlwriter)
c_xmlwriter *c_xmlwriter::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_xmlwriter::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_xmlwriter::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_xmlwriter::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_xmlwriter::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_xmlwriter::cloneImpl() {
  c_xmlwriter *obj = NEW(c_xmlwriter)();
  cloneSet(obj);
  return obj;
}
void c_xmlwriter::cloneSet(c_xmlwriter *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_xmlwriter
Variant c_xmlwriter::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD(0x1EBCBEA66B6B0982LL, writecdata) {
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        return (t_writecdata(params[0]));
      }
      break;
    case 3:
      HASH_GUARD(0x55E29E84E96ACF83LL, startdtd) {
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        if (count <= 1) return (t_startdtd(params[0]));
        if (count == 2) return (t_startdtd(params[0], params[1]));
        return (t_startdtd(params[0], params[1], params[2]));
      }
      break;
    case 8:
      HASH_GUARD(0x7C1FF8A79BAB3608LL, writedtd) {
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        if (count <= 1) return (t_writedtd(params[0]));
        if (count == 2) return (t_writedtd(params[0], params[1]));
        if (count == 3) return (t_writedtd(params[0], params[1], params[2]));
        return (t_writedtd(params[0], params[1], params[2], params[3]));
      }
      break;
    case 14:
      HASH_GUARD(0x119CC9E7C3E7EF0ELL, openmemory) {
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD(0x0A7FE14C41766610LL, endcdata) {
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD(0x75F8C992981A4093LL, writecomment) {
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        return (t_writecomment(params[0]));
      }
      HASH_GUARD(0x5A7AE5A26994FF13LL, startattribute) {
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        return (t_startattribute(params[0]));
      }
      break;
    case 28:
      HASH_GUARD(0x337EFFF3783B919CLL, writeelement) {
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        if (count <= 1) return (t_writeelement(params[0]));
        return (t_writeelement(params[0], params[1]));
      }
      break;
    case 29:
      HASH_GUARD(0x4D26D167066BB11DLL, text) {
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        return (t_text(params[0]));
      }
      break;
    case 32:
      HASH_GUARD(0x7DF0368A44C01B20LL, startcdata) {
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD(0x5D49A460168D5C21LL, endpi) {
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD(0x1D81ABDC9890C5A9LL, writedtdattlist) {
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        return (t_writedtdattlist(params[0], params[1]));
      }
      break;
    case 43:
      HASH_GUARD(0x0DEAF425F1AD73ABLL, setindentstring) {
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        return (t_setindentstring(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x78A7A5D96EF2F4AFLL, endelement) {
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD(0x75B357D89DDE6EB5LL, endcomment) {
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD(0x4B0F1F6361A59C37LL, writeraw) {
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        return (t_writeraw(params[0]));
      }
      break;
    case 56:
      HASH_GUARD(0x7FC89CF1AFFB1E38LL, startdocument) {
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        if (count <= 0) return (t_startdocument());
        if (count == 1) return (t_startdocument(params[0]));
        if (count == 2) return (t_startdocument(params[0], params[1]));
        return (t_startdocument(params[0], params[1], params[2]));
      }
      break;
    case 58:
      HASH_GUARD(0x0D155D1E5C6641BALL, outputmemory) {
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        if (count <= 0) return (t_outputmemory());
        return (t_outputmemory(params[0]));
      }
      break;
    case 62:
      HASH_GUARD(0x1FBE635680ADB7BELL, openuri) {
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        return (t_openuri(params[0]));
      }
      break;
    case 68:
      HASH_GUARD(0x275896BFD7A77144LL, enddtd) {
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD(0x5D4650E5C0DAEE46LL, writedtdentity) {
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        if (count <= 2) return (t_writedtdentity(params[0], params[1]));
        if (count == 3) return (t_writedtdentity(params[0], params[1], params[2]));
        if (count == 4) return (t_writedtdentity(params[0], params[1], params[2], params[3]));
        if (count == 5) return (t_writedtdentity(params[0], params[1], params[2], params[3], params[4]));
        return (t_writedtdentity(params[0], params[1], params[2], params[3], params[4], params[5]));
      }
      break;
    case 71:
      HASH_GUARD(0x017687FD7029CCC7LL, enddtdelement) {
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD(0x3954A2C0306CCCCBLL, writeattribute) {
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        return (t_writeattribute(params[0], params[1]));
      }
      HASH_GUARD(0x7C43ECE80FF886CBLL, endattribute) {
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD(0x4F1D890D5B36D24DLL, startattributens) {
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        return (t_startattributens(params[0], params[1], params[2]));
      }
      break;
    case 82:
      HASH_GUARD(0x1357CA1E92397452LL, writedtdelement) {
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        return (t_writedtdelement(params[0], params[1]));
      }
      break;
    case 84:
      HASH_GUARD(0x154AE94AEFAC7C54LL, writeattributens) {
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        return (t_writeattributens(params[0], params[1], params[2], params[3]));
      }
      break;
    case 86:
      HASH_GUARD(0x4520735705A382D6LL, enddtdentity) {
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        return (t_enddtdentity());
      }
      HASH_GUARD(0x37D51A94C6EE8F56LL, writepi) {
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        return (t_writepi(params[0], params[1]));
      }
      break;
    case 88:
      HASH_GUARD(0x24A376E9310BF058LL, writeelementns) {
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        if (count <= 3) return (t_writeelementns(params[0], params[1], params[2]));
        return (t_writeelementns(params[0], params[1], params[2], params[3]));
      }
      break;
    case 89:
      HASH_GUARD(0x390B6C01AE7C4159LL, startpi) {
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        return (t_startpi(params[0]));
      }
      break;
    case 92:
      HASH_GUARD(0x0DC5AC1E0A2F63DCLL, enddocument) {
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD(0x75A033B824EA1ADDLL, startdtdentity) {
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        return (t_startdtdentity(params[0], params[1]));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD(0x55BFFBE5717EFD62LL, startelement) {
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        return (t_startelement(params[0]));
      }
      break;
    case 101:
      HASH_GUARD(0x349B7446B5EE65E5LL, setindent) {
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        return (t_setindent(params[0]));
      }
      break;
    case 105:
      HASH_GUARD(0x608A2D39DE12E169LL, startelementns) {
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        return (t_startelementns(params[0], params[1], params[2]));
      }
      break;
    case 112:
      HASH_GUARD(0x0CBB10FA542B7D70LL, startdtdattlist) {
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        return (t_startdtdattlist(params[0]));
      }
      break;
    case 113:
      HASH_GUARD(0x496175DBD52E1771LL, enddtdattlist) {
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD(0x451436438EBA2AF8LL, startdtdelement) {
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        return (t_startdtdelement(params[0]));
      }
      break;
    case 122:
      HASH_GUARD(0x6A3D9F8EDB005E7ALL, flush) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        return (t_flush(params[0]));
      }
      break;
    case 126:
      HASH_GUARD(0x3174CCE00BFB9FFELL, fullendelement) {
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD(0x6A8CC27A7F0466FFLL, startcomment) {
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_xmlwriter
Variant c_xmlwriter::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD(0x1EBCBEA66B6B0982LL, writecdata) {
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        return (t_writecdata(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x55E29E84E96ACF83LL, startdtd) {
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        if (count <= 1) return (t_startdtd(a0));
        if (count == 2) return (t_startdtd(a0, a1));
        return (t_startdtd(a0, a1, a2));
      }
      break;
    case 8:
      HASH_GUARD(0x7C1FF8A79BAB3608LL, writedtd) {
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        if (count <= 1) return (t_writedtd(a0));
        if (count == 2) return (t_writedtd(a0, a1));
        if (count == 3) return (t_writedtd(a0, a1, a2));
        return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x119CC9E7C3E7EF0ELL, openmemory) {
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD(0x0A7FE14C41766610LL, endcdata) {
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD(0x75F8C992981A4093LL, writecomment) {
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        return (t_writecomment(a0));
      }
      HASH_GUARD(0x5A7AE5A26994FF13LL, startattribute) {
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        return (t_startattribute(a0));
      }
      break;
    case 28:
      HASH_GUARD(0x337EFFF3783B919CLL, writeelement) {
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        if (count <= 1) return (t_writeelement(a0));
        return (t_writeelement(a0, a1));
      }
      break;
    case 29:
      HASH_GUARD(0x4D26D167066BB11DLL, text) {
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        return (t_text(a0));
      }
      break;
    case 32:
      HASH_GUARD(0x7DF0368A44C01B20LL, startcdata) {
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD(0x5D49A460168D5C21LL, endpi) {
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD(0x1D81ABDC9890C5A9LL, writedtdattlist) {
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 43:
      HASH_GUARD(0x0DEAF425F1AD73ABLL, setindentstring) {
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        return (t_setindentstring(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x78A7A5D96EF2F4AFLL, endelement) {
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD(0x75B357D89DDE6EB5LL, endcomment) {
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD(0x4B0F1F6361A59C37LL, writeraw) {
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        return (t_writeraw(a0));
      }
      break;
    case 56:
      HASH_GUARD(0x7FC89CF1AFFB1E38LL, startdocument) {
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        if (count <= 0) return (t_startdocument());
        if (count == 1) return (t_startdocument(a0));
        if (count == 2) return (t_startdocument(a0, a1));
        return (t_startdocument(a0, a1, a2));
      }
      break;
    case 58:
      HASH_GUARD(0x0D155D1E5C6641BALL, outputmemory) {
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        if (count <= 0) return (t_outputmemory());
        return (t_outputmemory(a0));
      }
      break;
    case 62:
      HASH_GUARD(0x1FBE635680ADB7BELL, openuri) {
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        return (t_openuri(a0));
      }
      break;
    case 68:
      HASH_GUARD(0x275896BFD7A77144LL, enddtd) {
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD(0x5D4650E5C0DAEE46LL, writedtdentity) {
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        if (count <= 2) return (t_writedtdentity(a0, a1));
        if (count == 3) return (t_writedtdentity(a0, a1, a2));
        if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 71:
      HASH_GUARD(0x017687FD7029CCC7LL, enddtdelement) {
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD(0x3954A2C0306CCCCBLL, writeattribute) {
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        return (t_writeattribute(a0, a1));
      }
      HASH_GUARD(0x7C43ECE80FF886CBLL, endattribute) {
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD(0x4F1D890D5B36D24DLL, startattributens) {
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 82:
      HASH_GUARD(0x1357CA1E92397452LL, writedtdelement) {
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 84:
      HASH_GUARD(0x154AE94AEFAC7C54LL, writeattributens) {
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 86:
      HASH_GUARD(0x4520735705A382D6LL, enddtdentity) {
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        return (t_enddtdentity());
      }
      HASH_GUARD(0x37D51A94C6EE8F56LL, writepi) {
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        return (t_writepi(a0, a1));
      }
      break;
    case 88:
      HASH_GUARD(0x24A376E9310BF058LL, writeelementns) {
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 89:
      HASH_GUARD(0x390B6C01AE7C4159LL, startpi) {
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        return (t_startpi(a0));
      }
      break;
    case 92:
      HASH_GUARD(0x0DC5AC1E0A2F63DCLL, enddocument) {
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD(0x75A033B824EA1ADDLL, startdtdentity) {
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD(0x55BFFBE5717EFD62LL, startelement) {
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        return (t_startelement(a0));
      }
      break;
    case 101:
      HASH_GUARD(0x349B7446B5EE65E5LL, setindent) {
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        return (t_setindent(a0));
      }
      break;
    case 105:
      HASH_GUARD(0x608A2D39DE12E169LL, startelementns) {
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 112:
      HASH_GUARD(0x0CBB10FA542B7D70LL, startdtdattlist) {
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        return (t_startdtdattlist(a0));
      }
      break;
    case 113:
      HASH_GUARD(0x496175DBD52E1771LL, enddtdattlist) {
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD(0x451436438EBA2AF8LL, startdtdelement) {
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        return (t_startdtdelement(a0));
      }
      break;
    case 122:
      HASH_GUARD(0x6A3D9F8EDB005E7ALL, flush) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        return (t_flush(a0));
      }
      break;
    case 126:
      HASH_GUARD(0x3174CCE00BFB9FFELL, fullendelement) {
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD(0x6A8CC27A7F0466FFLL, startcomment) {
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_xmlwriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_xmlwriter
Variant c_xmlwriter::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_xmlwriter
Variant c_xmlwriter::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD(0x1EBCBEA66B6B0982LL, writecdata) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecdata(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x55E29E84E96ACF83LL, startdtd) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_startdtd(a0));
        else if (count == 2) return (t_startdtd(a0, a1));
        else return (t_startdtd(a0, a1, a2));
      }
      break;
    case 8:
      HASH_GUARD(0x7C1FF8A79BAB3608LL, writedtd) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writedtd(a0));
        else if (count == 2) return (t_writedtd(a0, a1));
        else if (count == 3) return (t_writedtd(a0, a1, a2));
        else return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x119CC9E7C3E7EF0ELL, openmemory) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD(0x0A7FE14C41766610LL, endcdata) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD(0x75F8C992981A4093LL, writecomment) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecomment(a0));
      }
      HASH_GUARD(0x5A7AE5A26994FF13LL, startattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattribute(a0));
      }
      break;
    case 28:
      HASH_GUARD(0x337EFFF3783B919CLL, writeelement) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writeelement(a0));
        else return (t_writeelement(a0, a1));
      }
      break;
    case 29:
      HASH_GUARD(0x4D26D167066BB11DLL, text) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_text(a0));
      }
      break;
    case 32:
      HASH_GUARD(0x7DF0368A44C01B20LL, startcdata) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD(0x5D49A460168D5C21LL, endpi) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD(0x1D81ABDC9890C5A9LL, writedtdattlist) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 43:
      HASH_GUARD(0x0DEAF425F1AD73ABLL, setindentstring) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindentstring(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x78A7A5D96EF2F4AFLL, endelement) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD(0x75B357D89DDE6EB5LL, endcomment) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD(0x4B0F1F6361A59C37LL, writeraw) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeraw(a0));
      }
      break;
    case 56:
      HASH_GUARD(0x7FC89CF1AFFB1E38LL, startdocument) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_startdocument());
        else if (count == 1) return (t_startdocument(a0));
        else if (count == 2) return (t_startdocument(a0, a1));
        else return (t_startdocument(a0, a1, a2));
      }
      break;
    case 58:
      HASH_GUARD(0x0D155D1E5C6641BALL, outputmemory) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_outputmemory());
        else return (t_outputmemory(a0));
      }
      break;
    case 62:
      HASH_GUARD(0x1FBE635680ADB7BELL, openuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openuri(a0));
      }
      break;
    case 68:
      HASH_GUARD(0x275896BFD7A77144LL, enddtd) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD(0x5D4650E5C0DAEE46LL, writedtdentity) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_writedtdentity(a0, a1));
        else if (count == 3) return (t_writedtdentity(a0, a1, a2));
        else if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        else if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        else return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 71:
      HASH_GUARD(0x017687FD7029CCC7LL, enddtdelement) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD(0x3954A2C0306CCCCBLL, writeattribute) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattribute(a0, a1));
      }
      HASH_GUARD(0x7C43ECE80FF886CBLL, endattribute) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD(0x4F1D890D5B36D24DLL, startattributens) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 82:
      HASH_GUARD(0x1357CA1E92397452LL, writedtdelement) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 84:
      HASH_GUARD(0x154AE94AEFAC7C54LL, writeattributens) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 86:
      HASH_GUARD(0x4520735705A382D6LL, enddtdentity) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdentity());
      }
      HASH_GUARD(0x37D51A94C6EE8F56LL, writepi) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writepi(a0, a1));
      }
      break;
    case 88:
      HASH_GUARD(0x24A376E9310BF058LL, writeelementns) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        else return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 89:
      HASH_GUARD(0x390B6C01AE7C4159LL, startpi) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startpi(a0));
      }
      break;
    case 92:
      HASH_GUARD(0x0DC5AC1E0A2F63DCLL, enddocument) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD(0x75A033B824EA1ADDLL, startdtdentity) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD(0x55BFFBE5717EFD62LL, startelement) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelement(a0));
      }
      break;
    case 101:
      HASH_GUARD(0x349B7446B5EE65E5LL, setindent) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindent(a0));
      }
      break;
    case 105:
      HASH_GUARD(0x608A2D39DE12E169LL, startelementns) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 112:
      HASH_GUARD(0x0CBB10FA542B7D70LL, startdtdattlist) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdattlist(a0));
      }
      break;
    case 113:
      HASH_GUARD(0x496175DBD52E1771LL, enddtdattlist) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD(0x451436438EBA2AF8LL, startdtdelement) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdelement(a0));
      }
      break;
    case 122:
      HASH_GUARD(0x6A3D9F8EDB005E7ALL, flush) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 126:
      HASH_GUARD(0x3174CCE00BFB9FFELL, fullendelement) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD(0x6A8CC27A7F0466FFLL, startcomment) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_xmlwriter::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_xmlwriter = {
  c_xmlwriter::os_getInit,
  c_xmlwriter::os_get,
  c_xmlwriter::os_lval,
  c_xmlwriter::os_invoke,
  c_xmlwriter::os_constant,
};
Object co_domexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domexception)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domexception
Variant c_domexception::os_getInit(const char *s, int64 hash) {
  return c_exception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domexception
Variant c_domexception::os_get(const char *s, int64 hash) {
  return c_exception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domexception
Variant &c_domexception::os_lval(const char *s, int64 hash) {
  return c_exception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domexception
void c_domexception::o_get(Array &props) const {
  c_exception::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_domexception
Variant c_domexception::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domexception::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domexception
Variant c_domexception::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_exception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domexception
Variant c_domexception::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domexception
bool c_domexception::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domexception::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domexception
bool c_domexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_exception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domexception
bool c_domexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_domexception
Variant c_domexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domexception::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domexception
Variant c_domexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_exception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domexception
Variant c_domexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domexception
Variant& c_domexception::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domexception::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domexception
Variant& c_domexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_exception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domexception
Variant& c_domexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domexception
Variant c_domexception::os_constant(const char *s) {
  return c_exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domexception
IMPLEMENT_CLASS(domexception)
c_domexception *c_domexception::create(String a0, int64 a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_domexception::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    if (count <= 0) (t___construct());
    else if (count == 1) (t___construct(params[0]));
    else (t___construct(params[0], params[1]));
  }
  return this;
}
void c_domexception::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  if (count <= 0) (t___construct());
  else if (count == 1) (t___construct(params[0]));
  else (t___construct(params[0], params[1]));
}
void c_domexception::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_domexception::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domexception::cloneImpl() {
  c_domexception *obj = NEW(c_domexception)();
  cloneSet(obj);
  return obj;
}
void c_domexception::cloneSet(c_domexception *clone) {
  c_exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domexception
Variant c_domexception::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domexception
Variant c_domexception::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domexception
Variant c_domexception::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domexception
Variant c_domexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domexception = {
  c_domexception::os_getInit,
  c_domexception::os_get,
  c_domexception::os_lval,
  c_domexception::os_invoke,
  c_domexception::os_constant,
};
Object co_domxpath(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domxpath)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domxpath
Variant c_domxpath::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domxpath
Variant c_domxpath::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domxpath
Variant &c_domxpath::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domxpath
void c_domxpath::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_get_domxpath
Variant c_domxpath::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domxpath::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domxpath
Variant c_domxpath::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domxpath
Variant c_domxpath::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domxpath
bool c_domxpath::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domxpath::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domxpath
bool c_domxpath::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domxpath
bool c_domxpath::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_set_domxpath
Variant c_domxpath::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domxpath::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domxpath
Variant c_domxpath::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domxpath
Variant c_domxpath::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domxpath
Variant& c_domxpath::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domxpath::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domxpath
Variant& c_domxpath::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domxpath
Variant& c_domxpath::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domxpath
Variant c_domxpath::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domxpath
IMPLEMENT_CLASS(domxpath)
c_domxpath *c_domxpath::create(Variant a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_domxpath::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    (t___construct(params[0]));
  }
  return this;
}
void c_domxpath::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  (t___construct(params[0]));
}
void c_domxpath::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_domxpath::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domxpath::cloneImpl() {
  c_domxpath *obj = NEW(c_domxpath)();
  cloneSet(obj);
  return obj;
}
void c_domxpath::cloneSet(c_domxpath *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_domxpath::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domxpath
Variant c_domxpath::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD(0x144FADF6B374AB82LL, registerphpfunctions) {
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        if (count <= 0) return (t_registerphpfunctions());
        return (t_registerphpfunctions(params[0]));
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 7:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        if (count <= 1) return (t_query(params[0]));
        return (t_query(params[0], params[1]));
      }
      break;
    case 8:
      HASH_GUARD(0x47ACFB6D8681B0E8LL, registernamespace) {
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        return (t_registernamespace(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(params[0]), null);
      }
      HASH_GUARD(0x2443593B6F3C912FLL, evaluate) {
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        if (count <= 1) return (t_evaluate(params[0]));
        return (t_evaluate(params[0], params[1]));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domxpath
Variant c_domxpath::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD(0x144FADF6B374AB82LL, registerphpfunctions) {
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        if (count <= 0) return (t_registerphpfunctions());
        return (t_registerphpfunctions(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        if (count <= 1) return (t_query(a0));
        return (t_query(a0, a1));
      }
      break;
    case 8:
      HASH_GUARD(0x47ACFB6D8681B0E8LL, registernamespace) {
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        return (t_registernamespace(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      HASH_GUARD(0x2443593B6F3C912FLL, evaluate) {
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        if (count <= 1) return (t_evaluate(a0));
        return (t_evaluate(a0, a1));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domxpath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domxpath
Variant c_domxpath::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domxpath
Variant c_domxpath::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD(0x144FADF6B374AB82LL, registerphpfunctions) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_registerphpfunctions());
        else return (t_registerphpfunctions(a0));
      }
      break;
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD(0x356758D4414DA377LL, query) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_query(a0));
        else return (t_query(a0, a1));
      }
      break;
    case 8:
      HASH_GUARD(0x47ACFB6D8681B0E8LL, registernamespace) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernamespace(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      HASH_GUARD(0x2443593B6F3C912FLL, evaluate) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_evaluate(a0));
        else return (t_evaluate(a0, a1));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domxpath::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domxpath = {
  c_domxpath::os_getInit,
  c_domxpath::os_get,
  c_domxpath::os_lval,
  c_domxpath::os_invoke,
  c_domxpath::os_constant,
};
Object co_soapserver(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapserver)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapserver
Variant c_soapserver::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapserver
Variant c_soapserver::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapserver
Variant &c_soapserver::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapserver
void c_soapserver::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapserver
Variant c_soapserver::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_soapserver::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapserver
Variant c_soapserver::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapserver
Variant c_soapserver::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapserver
bool c_soapserver::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_soapserver::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapserver
bool c_soapserver::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapserver
bool c_soapserver::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapserver
Variant c_soapserver::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_soapserver::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapserver
Variant c_soapserver::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapserver
Variant c_soapserver::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapserver
Variant& c_soapserver::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_soapserver::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapserver
Variant& c_soapserver::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapserver
Variant& c_soapserver::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapserver
Variant c_soapserver::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapserver
IMPLEMENT_CLASS(soapserver)
c_soapserver *c_soapserver::create(Variant a0, Array a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_soapserver::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    if (count <= 1) (t___construct(params[0]));
    else (t___construct(params[0], params[1]));
  }
  return this;
}
void c_soapserver::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  if (count <= 1) (t___construct(params[0]));
  else (t___construct(params[0], params[1]));
}
void c_soapserver::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_soapserver::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapserver::cloneImpl() {
  c_soapserver *obj = NEW(c_soapserver)();
  cloneSet(obj);
  return obj;
}
void c_soapserver::cloneSet(c_soapserver *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapserver
Variant c_soapserver::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x758A4E04590FE203LL, fault) {
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        if (count <= 2) return (t_fault(params[0], params[1]), null);
        if (count == 3) return (t_fault(params[0], params[1], params[2]), null);
        if (count == 4) return (t_fault(params[0], params[1], params[2], params[3]), null);
        return (t_fault(params[0], params[1], params[2], params[3], params[4]), null);
      }
      break;
    case 8:
      HASH_GUARD(0x5E77DD94E0A69328LL, setpersistence) {
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        return (t_setpersistence(params[0]), null);
      }
      break;
    case 15:
      HASH_GUARD(0x652BDFA6E22F17AFLL, getfunctions) {
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD(0x5C4CA333F4541532LL, handle) {
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        if (count <= 0) return (t_handle(), null);
        return (t_handle(params[0]), null);
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x597B151CC4F70834LL, setclass) {
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        if (count <= 1) return (t_setclass(count, params[0]), null);
        return (t_setclass(count,params[0], params.slice(1, count - 1, false)), null);
      }
      break;
    case 25:
      HASH_GUARD(0x559622F84FE626B9LL, setobject) {
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        return (t_setobject(params[0]), null);
      }
      break;
    case 30:
      HASH_GUARD(0x278B0E6CCA74963ELL, addsoapheader) {
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        return (t_addsoapheader(params[0]), null);
      }
      break;
    case 31:
      HASH_GUARD(0x48B5852A397D2D9FLL, addfunction) {
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        return (t_addfunction(params[0]), null);
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapserver
Variant c_soapserver::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x758A4E04590FE203LL, fault) {
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        if (count <= 2) return (t_fault(a0, a1), null);
        if (count == 3) return (t_fault(a0, a1, a2), null);
        if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 8:
      HASH_GUARD(0x5E77DD94E0A69328LL, setpersistence) {
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        return (t_setpersistence(a0), null);
      }
      break;
    case 15:
      HASH_GUARD(0x652BDFA6E22F17AFLL, getfunctions) {
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD(0x5C4CA333F4541532LL, handle) {
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        if (count <= 0) return (t_handle(), null);
        return (t_handle(a0), null);
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x597B151CC4F70834LL, setclass) {
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        if (count <= 1) return (t_setclass(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_setclass(count,a0, params), null);
      }
      break;
    case 25:
      HASH_GUARD(0x559622F84FE626B9LL, setobject) {
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        return (t_setobject(a0), null);
      }
      break;
    case 30:
      HASH_GUARD(0x278B0E6CCA74963ELL, addsoapheader) {
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        return (t_addsoapheader(a0), null);
      }
      break;
    case 31:
      HASH_GUARD(0x48B5852A397D2D9FLL, addfunction) {
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        return (t_addfunction(a0), null);
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapserver
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapserver
Variant c_soapserver::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapserver
Variant c_soapserver::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x758A4E04590FE203LL, fault) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_fault(a0, a1), null);
        else if (count == 3) return (t_fault(a0, a1, a2), null);
        else if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        else return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 8:
      HASH_GUARD(0x5E77DD94E0A69328LL, setpersistence) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setpersistence(a0), null);
      }
      break;
    case 15:
      HASH_GUARD(0x652BDFA6E22F17AFLL, getfunctions) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD(0x5C4CA333F4541532LL, handle) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_handle(), null);
        else return (t_handle(a0), null);
      }
      break;
    case 19:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD(0x597B151CC4F70834LL, setclass) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setclass(count, a0), null);
        return (t_setclass(count, a0,vargs), null);
      }
      break;
    case 25:
      HASH_GUARD(0x559622F84FE626B9LL, setobject) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setobject(a0), null);
      }
      break;
    case 30:
      HASH_GUARD(0x278B0E6CCA74963ELL, addsoapheader) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addsoapheader(a0), null);
      }
      break;
    case 31:
      HASH_GUARD(0x48B5852A397D2D9FLL, addfunction) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addfunction(a0), null);
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapserver::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapserver = {
  c_soapserver::os_getInit,
  c_soapserver::os_get,
  c_soapserver::os_lval,
  c_soapserver::os_invoke,
  c_soapserver::os_constant,
};
Object co_domnode(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domnode)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnode
Variant c_domnode::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnode
Variant c_domnode::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnode
Variant &c_domnode::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domnode
void c_domnode::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_get_domnode
Variant c_domnode::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domnode::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnode
Variant c_domnode::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnode
Variant c_domnode::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domnode
bool c_domnode::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domnode::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnode
bool c_domnode::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnode
bool c_domnode::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_set_domnode
Variant c_domnode::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domnode::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnode
Variant c_domnode::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnode
Variant c_domnode::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domnode
Variant& c_domnode::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domnode::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnode
Variant& c_domnode::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnode
Variant& c_domnode::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domnode
Variant c_domnode::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domnode
IMPLEMENT_CLASS(domnode)
c_domnode *c_domnode::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_domnode::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_domnode::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_domnode::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_domnode::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domnode::cloneImpl() {
  c_domnode *obj = NEW(c_domnode)();
  cloneSet(obj);
  return obj;
}
void c_domnode::cloneSet(c_domnode *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_domnode::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnode
Variant c_domnode::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domnode
Variant c_domnode::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domnode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnode
Variant c_domnode::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domnode
Variant c_domnode::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domnode::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domnode = {
  c_domnode::os_getInit,
  c_domnode::os_get,
  c_domnode::os_lval,
  c_domnode::os_invoke,
  c_domnode::os_constant,
};
Object co_domdocument(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domdocument)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocument
Variant c_domdocument::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocument
Variant c_domdocument::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocument
Variant &c_domdocument::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocument
void c_domdocument::o_get(Array &props) const {
  c_domnode::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_get_domdocument
Variant c_domdocument::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domdocument::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocument
Variant c_domdocument::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocument
Variant c_domdocument::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domdocument
bool c_domdocument::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domdocument::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocument
bool c_domdocument::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocument
bool c_domdocument::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_set_domdocument
Variant c_domdocument::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domdocument::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocument
Variant c_domdocument::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocument
Variant c_domdocument::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domdocument
Variant& c_domdocument::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domdocument::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocument
Variant& c_domdocument::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocument
Variant& c_domdocument::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocument
Variant c_domdocument::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domdocument
IMPLEMENT_CLASS(domdocument)
c_domdocument *c_domdocument::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_domdocument::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    if (count <= 0) (t___construct());
    else if (count == 1) (t___construct(params[0]));
    else (t___construct(params[0], params[1]));
  }
  return this;
}
void c_domdocument::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  if (count <= 0) (t___construct());
  else if (count == 1) (t___construct(params[0]));
  else (t___construct(params[0], params[1]));
}
void c_domdocument::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_domdocument::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domdocument::cloneImpl() {
  c_domdocument *obj = NEW(c_domdocument)();
  cloneSet(obj);
  return obj;
}
void c_domdocument::cloneSet(c_domdocument *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domdocument::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocument
Variant c_domdocument::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD(0x515FE7746601E385LL, getelementbyid) {
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        return (t_getelementbyid(params[0]));
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      HASH_GUARD(0x142A28F8CE4A4E8ALL, xinclude) {
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        if (count <= 0) return (t_xinclude());
        return (t_xinclude(params[0]));
      }
      break;
    case 13:
      HASH_GUARD(0x0D128C363EBF7F0DLL, createcdatasection) {
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        return (t_createcdatasection(params[0]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 17:
      HASH_GUARD(0x69C6F7D584EC5011LL, schemavalidatesource) {
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        return (t_schemavalidatesource(params[0]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 20:
      HASH_GUARD(0x04F8F7CEA46D0514LL, save) {
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        if (count <= 1) return (t_save(params[0]));
        return (t_save(params[0], params[1]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      HASH_GUARD(0x2FC58024A75AEB15LL, createattributens) {
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        return (t_createattributens(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 28:
      HASH_GUARD(0x1A78385D7CD10A1CLL, relaxngvalidate) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        return (t_relaxngvalidate(params[0]));
      }
      break;
    case 34:
      HASH_GUARD(0x1B0F4D437C8404A2LL, loadhtml) {
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        return (t_loadhtml(params[0]));
      }
      HASH_GUARD(0x4C40B0F935B39FA2LL, createelement) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        if (count <= 1) return (t_createelement(params[0]));
        return (t_createelement(params[0], params[1]));
      }
      break;
    case 44:
      HASH_GUARD(0x1304C35F6E006FACLL, relaxngvalidatesource) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        return (t_relaxngvalidatesource(params[0]));
      }
      HASH_GUARD(0x2BFDE9CF0FE9A82CLL, createattribute) {
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        return (t_createattribute(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x4A6C6D9AB88CD42FLL, importnode) {
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        if (count <= 1) return (t_importnode(params[0]));
        return (t_importnode(params[0], params[1]));
      }
      HASH_GUARD(0x5FE94CA513F14AAFLL, loadhtmlfile) {
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        return (t_loadhtmlfile(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD(0x20E2B2FD2B7AE431LL, loadxml) {
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        if (count <= 1) return (t_loadxml(params[0]));
        return (t_loadxml(params[0], params[1]));
      }
      break;
    case 50:
      HASH_GUARD(0x7A9C4709CAD09832LL, createentityreference) {
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        return (t_createentityreference(params[0]));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      break;
    case 55:
      HASH_GUARD(0x1CA408E02262F737LL, validate) {
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        return (t_validate());
      }
      break;
    case 67:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 71:
      HASH_GUARD(0x29C79E90C6FCC0C7LL, createcomment) {
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        return (t_createcomment(params[0]));
      }
      break;
    case 72:
      HASH_GUARD(0x7EB8C68BABDC5648LL, schemavalidate) {
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        return (t_schemavalidate(params[0]));
      }
      break;
    case 74:
      HASH_GUARD(0x3FFA3F55ECAB93CALL, getelementsbytagname) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(params[0]));
      }
      HASH_GUARD(0x1A9CC561CA4817CALL, getelementsbytagnamens) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(params[0], params[1]));
      }
      break;
    case 77:
      HASH_GUARD(0x35C0FF513ED3054DLL, savehtmlfile) {
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        return (t_savehtmlfile(params[0]));
      }
      break;
    case 79:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      break;
    case 83:
      HASH_GUARD(0x21F3F1C9058310D3LL, savehtml) {
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        return (t_savehtml());
      }
      break;
    case 90:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 93:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      HASH_GUARD(0x79B7A5774A0943DFLL, load) {
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        if (count <= 1) return (t_load(params[0]));
        return (t_load(params[0], params[1]));
      }
      break;
    case 97:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 100:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      break;
    case 101:
      HASH_GUARD(0x26D66F56DDDC32E5LL, savexml) {
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        if (count <= 0) return (t_savexml());
        if (count == 1) return (t_savexml(params[0]));
        return (t_savexml(params[0], params[1]));
      }
      break;
    case 106:
      HASH_GUARD(0x0AC931EAB2FE3D6ALL, normalizedocument) {
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD(0x05EA36F416B7EBEBLL, createelementns) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        if (count <= 2) return (t_createelementns(params[0], params[1]));
        return (t_createelementns(params[0], params[1], params[2]));
      }
      break;
    case 109:
      HASH_GUARD(0x2A99431FC6E7BA6DLL, createprocessinginstruction) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        if (count <= 1) return (t_createprocessinginstruction(params[0]));
        return (t_createprocessinginstruction(params[0], params[1]));
      }
      break;
    case 111:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD(0x615771958E1EB375LL, registernodeclass) {
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        return (t_registernodeclass(params[0], params[1]));
      }
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 120:
      HASH_GUARD(0x44FD8C24F4EA46F8LL, createdocumentfragment) {
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        return (t_createdocumentfragment());
      }
      break;
    case 122:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 123:
      HASH_GUARD(0x6056A5BB9855D7FBLL, createtextnode) {
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        return (t_createtextnode(params[0]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domdocument
Variant c_domdocument::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD(0x515FE7746601E385LL, getelementbyid) {
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        return (t_getelementbyid(a0));
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD(0x142A28F8CE4A4E8ALL, xinclude) {
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        if (count <= 0) return (t_xinclude());
        return (t_xinclude(a0));
      }
      break;
    case 13:
      HASH_GUARD(0x0D128C363EBF7F0DLL, createcdatasection) {
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        return (t_createcdatasection(a0));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 17:
      HASH_GUARD(0x69C6F7D584EC5011LL, schemavalidatesource) {
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        return (t_schemavalidatesource(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 20:
      HASH_GUARD(0x04F8F7CEA46D0514LL, save) {
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        if (count <= 1) return (t_save(a0));
        return (t_save(a0, a1));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      HASH_GUARD(0x2FC58024A75AEB15LL, createattributens) {
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        return (t_createattributens(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 28:
      HASH_GUARD(0x1A78385D7CD10A1CLL, relaxngvalidate) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        return (t_relaxngvalidate(a0));
      }
      break;
    case 34:
      HASH_GUARD(0x1B0F4D437C8404A2LL, loadhtml) {
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        return (t_loadhtml(a0));
      }
      HASH_GUARD(0x4C40B0F935B39FA2LL, createelement) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        if (count <= 1) return (t_createelement(a0));
        return (t_createelement(a0, a1));
      }
      break;
    case 44:
      HASH_GUARD(0x1304C35F6E006FACLL, relaxngvalidatesource) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        return (t_relaxngvalidatesource(a0));
      }
      HASH_GUARD(0x2BFDE9CF0FE9A82CLL, createattribute) {
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        return (t_createattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x4A6C6D9AB88CD42FLL, importnode) {
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        if (count <= 1) return (t_importnode(a0));
        return (t_importnode(a0, a1));
      }
      HASH_GUARD(0x5FE94CA513F14AAFLL, loadhtmlfile) {
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        return (t_loadhtmlfile(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD(0x20E2B2FD2B7AE431LL, loadxml) {
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        if (count <= 1) return (t_loadxml(a0));
        return (t_loadxml(a0, a1));
      }
      break;
    case 50:
      HASH_GUARD(0x7A9C4709CAD09832LL, createentityreference) {
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        return (t_createentityreference(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 55:
      HASH_GUARD(0x1CA408E02262F737LL, validate) {
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        return (t_validate());
      }
      break;
    case 67:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 71:
      HASH_GUARD(0x29C79E90C6FCC0C7LL, createcomment) {
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        return (t_createcomment(a0));
      }
      break;
    case 72:
      HASH_GUARD(0x7EB8C68BABDC5648LL, schemavalidate) {
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        return (t_schemavalidate(a0));
      }
      break;
    case 74:
      HASH_GUARD(0x3FFA3F55ECAB93CALL, getelementsbytagname) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD(0x1A9CC561CA4817CALL, getelementsbytagnamens) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 77:
      HASH_GUARD(0x35C0FF513ED3054DLL, savehtmlfile) {
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        return (t_savehtmlfile(a0));
      }
      break;
    case 79:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 83:
      HASH_GUARD(0x21F3F1C9058310D3LL, savehtml) {
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        return (t_savehtml());
      }
      break;
    case 90:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 93:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      HASH_GUARD(0x79B7A5774A0943DFLL, load) {
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        if (count <= 1) return (t_load(a0));
        return (t_load(a0, a1));
      }
      break;
    case 97:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 101:
      HASH_GUARD(0x26D66F56DDDC32E5LL, savexml) {
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        if (count <= 0) return (t_savexml());
        if (count == 1) return (t_savexml(a0));
        return (t_savexml(a0, a1));
      }
      break;
    case 106:
      HASH_GUARD(0x0AC931EAB2FE3D6ALL, normalizedocument) {
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD(0x05EA36F416B7EBEBLL, createelementns) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        if (count <= 2) return (t_createelementns(a0, a1));
        return (t_createelementns(a0, a1, a2));
      }
      break;
    case 109:
      HASH_GUARD(0x2A99431FC6E7BA6DLL, createprocessinginstruction) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        if (count <= 1) return (t_createprocessinginstruction(a0));
        return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 111:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD(0x615771958E1EB375LL, registernodeclass) {
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        return (t_registernodeclass(a0, a1));
      }
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 120:
      HASH_GUARD(0x44FD8C24F4EA46F8LL, createdocumentfragment) {
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        return (t_createdocumentfragment());
      }
      break;
    case 122:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 123:
      HASH_GUARD(0x6056A5BB9855D7FBLL, createtextnode) {
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        return (t_createtextnode(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domdocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocument
Variant c_domdocument::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domdocument
Variant c_domdocument::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD(0x515FE7746601E385LL, getelementbyid) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementbyid(a0));
      }
      break;
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD(0x142A28F8CE4A4E8ALL, xinclude) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_xinclude());
        else return (t_xinclude(a0));
      }
      break;
    case 13:
      HASH_GUARD(0x0D128C363EBF7F0DLL, createcdatasection) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcdatasection(a0));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 17:
      HASH_GUARD(0x69C6F7D584EC5011LL, schemavalidatesource) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidatesource(a0));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 20:
      HASH_GUARD(0x04F8F7CEA46D0514LL, save) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_save(a0));
        else return (t_save(a0, a1));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      HASH_GUARD(0x2FC58024A75AEB15LL, createattributens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattributens(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 28:
      HASH_GUARD(0x1A78385D7CD10A1CLL, relaxngvalidate) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidate(a0));
      }
      break;
    case 34:
      HASH_GUARD(0x1B0F4D437C8404A2LL, loadhtml) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtml(a0));
      }
      HASH_GUARD(0x4C40B0F935B39FA2LL, createelement) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createelement(a0));
        else return (t_createelement(a0, a1));
      }
      break;
    case 44:
      HASH_GUARD(0x1304C35F6E006FACLL, relaxngvalidatesource) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidatesource(a0));
      }
      HASH_GUARD(0x2BFDE9CF0FE9A82CLL, createattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x4A6C6D9AB88CD42FLL, importnode) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_importnode(a0));
        else return (t_importnode(a0, a1));
      }
      HASH_GUARD(0x5FE94CA513F14AAFLL, loadhtmlfile) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtmlfile(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      HASH_GUARD(0x20E2B2FD2B7AE431LL, loadxml) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_loadxml(a0));
        else return (t_loadxml(a0, a1));
      }
      break;
    case 50:
      HASH_GUARD(0x7A9C4709CAD09832LL, createentityreference) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createentityreference(a0));
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 55:
      HASH_GUARD(0x1CA408E02262F737LL, validate) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_validate());
      }
      break;
    case 67:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 71:
      HASH_GUARD(0x29C79E90C6FCC0C7LL, createcomment) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcomment(a0));
      }
      break;
    case 72:
      HASH_GUARD(0x7EB8C68BABDC5648LL, schemavalidate) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidate(a0));
      }
      break;
    case 74:
      HASH_GUARD(0x3FFA3F55ECAB93CALL, getelementsbytagname) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD(0x1A9CC561CA4817CALL, getelementsbytagnamens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 77:
      HASH_GUARD(0x35C0FF513ED3054DLL, savehtmlfile) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtmlfile(a0));
      }
      break;
    case 79:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 83:
      HASH_GUARD(0x21F3F1C9058310D3LL, savehtml) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtml());
      }
      break;
    case 90:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 93:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      HASH_GUARD(0x79B7A5774A0943DFLL, load) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_load(a0));
        else return (t_load(a0, a1));
      }
      break;
    case 97:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 101:
      HASH_GUARD(0x26D66F56DDDC32E5LL, savexml) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_savexml());
        else if (count == 1) return (t_savexml(a0));
        else return (t_savexml(a0, a1));
      }
      break;
    case 106:
      HASH_GUARD(0x0AC931EAB2FE3D6ALL, normalizedocument) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD(0x05EA36F416B7EBEBLL, createelementns) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createelementns(a0, a1));
        else return (t_createelementns(a0, a1, a2));
      }
      break;
    case 109:
      HASH_GUARD(0x2A99431FC6E7BA6DLL, createprocessinginstruction) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createprocessinginstruction(a0));
        else return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 111:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD(0x615771958E1EB375LL, registernodeclass) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernodeclass(a0, a1));
      }
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 120:
      HASH_GUARD(0x44FD8C24F4EA46F8LL, createdocumentfragment) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createdocumentfragment());
      }
      break;
    case 122:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 123:
      HASH_GUARD(0x6056A5BB9855D7FBLL, createtextnode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createtextnode(a0));
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domdocument::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domdocument = {
  c_domdocument::os_getInit,
  c_domdocument::os_get,
  c_domdocument::os_lval,
  c_domdocument::os_invoke,
  c_domdocument::os_constant,
};
Object co_libxmlerror(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_libxmlerror)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_libxmlerror
Variant c_libxmlerror::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_libxmlerror
Variant c_libxmlerror::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_libxmlerror
Variant &c_libxmlerror::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_libxmlerror
void c_libxmlerror::o_get(Array &props) const {
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_get_libxmlerror
Variant c_libxmlerror::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_libxmlerror::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_libxmlerror
Variant c_libxmlerror::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_libxmlerror
Variant c_libxmlerror::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_exists_libxmlerror
bool c_libxmlerror::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_libxmlerror::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_libxmlerror
bool c_libxmlerror::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_libxmlerror
bool c_libxmlerror::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_set_libxmlerror
Variant c_libxmlerror::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_libxmlerror::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_libxmlerror
Variant c_libxmlerror::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_libxmlerror
Variant c_libxmlerror::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_lval_libxmlerror
Variant& c_libxmlerror::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_libxmlerror::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_libxmlerror
Variant& c_libxmlerror::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_libxmlerror
Variant& c_libxmlerror::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_libxmlerror
Variant c_libxmlerror::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_libxmlerror
IMPLEMENT_CLASS(libxmlerror)
c_libxmlerror *c_libxmlerror::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_libxmlerror::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_libxmlerror::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_libxmlerror::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_libxmlerror::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_libxmlerror::cloneImpl() {
  c_libxmlerror *obj = NEW(c_libxmlerror)();
  cloneSet(obj);
  return obj;
}
void c_libxmlerror::cloneSet(c_libxmlerror *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_libxmlerror
Variant c_libxmlerror::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_libxmlerror
Variant c_libxmlerror::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_libxmlerror
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_libxmlerror
Variant c_libxmlerror::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_libxmlerror
Variant c_libxmlerror::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_libxmlerror::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_libxmlerror = {
  c_libxmlerror::os_getInit,
  c_libxmlerror::os_get,
  c_libxmlerror::os_lval,
  c_libxmlerror::os_invoke,
  c_libxmlerror::os_constant,
};
Object co_soapfault(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_soapfault)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapfault
Variant c_soapfault::os_getInit(const char *s, int64 hash) {
  return c_exception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapfault
Variant c_soapfault::os_get(const char *s, int64 hash) {
  return c_exception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapfault
Variant &c_soapfault::os_lval(const char *s, int64 hash) {
  return c_exception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_soapfault
void c_soapfault::o_get(Array &props) const {
  c_exception::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_get_soapfault
Variant c_soapfault::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_soapfault::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapfault
Variant c_soapfault::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_exception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapfault
Variant c_soapfault::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_exists_soapfault
bool c_soapfault::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_soapfault::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapfault
bool c_soapfault::o_existsPublic(CStrRef s, int64 hash) const {
  return c_exception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapfault
bool c_soapfault::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_set_soapfault
Variant c_soapfault::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_soapfault::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapfault
Variant c_soapfault::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_exception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapfault
Variant c_soapfault::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_lval_soapfault
Variant& c_soapfault::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_soapfault::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapfault
Variant& c_soapfault::o_lvalPublic(CStrRef s, int64 hash) {
  return c_exception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapfault
Variant& c_soapfault::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_soapfault
Variant c_soapfault::os_constant(const char *s) {
  return c_exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_soapfault
IMPLEMENT_CLASS(soapfault)
c_soapfault *c_soapfault::create(Variant a0, String a1, String a2, Variant a3, String a4, Variant a5) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4, a5);
  return this;
}
ObjectData *c_soapfault::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
    if (count <= 2) (t___construct(params[0], params[1]));
    else if (count == 3) (t___construct(params[0], params[1], params[2]));
    else if (count == 4) (t___construct(params[0], params[1], params[2], params[3]));
    else if (count == 5) (t___construct(params[0], params[1], params[2], params[3], params[4]));
    else (t___construct(params[0], params[1], params[2], params[3], params[4], params[5]));
  }
  return this;
}
void c_soapfault::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
  if (count <= 2) (t___construct(params[0], params[1]));
  else if (count == 3) (t___construct(params[0], params[1], params[2]));
  else if (count == 4) (t___construct(params[0], params[1], params[2], params[3]));
  else if (count == 5) (t___construct(params[0], params[1], params[2], params[3], params[4]));
  else (t___construct(params[0], params[1], params[2], params[3], params[4], params[5]));
}
void c_soapfault::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else if (count == 5) (t___construct(a0, a1, a2, a3, a4), null);
  else (t___construct(a0, a1, a2, a3, a4, a5), null);
}
void c_soapfault::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_soapfault::cloneImpl() {
  c_soapfault *obj = NEW(c_soapfault)();
  cloneSet(obj);
  return obj;
}
void c_soapfault::cloneSet(c_soapfault *clone) {
  c_exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapfault
Variant c_soapfault::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(params[0], params[1]), null);
        if (count == 3) return (t___construct(params[0], params[1], params[2]), null);
        if (count == 4) return (t___construct(params[0], params[1], params[2], params[3]), null);
        if (count == 5) return (t___construct(params[0], params[1], params[2], params[3], params[4]), null);
        return (t___construct(params[0], params[1], params[2], params[3], params[4], params[5]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_soapfault
Variant c_soapfault::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_soapfault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapfault
Variant c_soapfault::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_soapfault
Variant c_soapfault::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  return c_exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_soapfault::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_soapfault = {
  c_soapfault::os_getInit,
  c_soapfault::os_get,
  c_soapfault::os_lval,
  c_soapfault::os_invoke,
  c_soapfault::os_constant,
};
Object co_domelement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domelement)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domelement
Variant c_domelement::os_getInit(const char *s, int64 hash) {
  return c_domnode::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domelement
Variant c_domelement::os_get(const char *s, int64 hash) {
  return c_domnode::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domelement
Variant &c_domelement::os_lval(const char *s, int64 hash) {
  return c_domnode::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domelement
void c_domelement::o_get(Array &props) const {
  c_domnode::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_domelement
Variant c_domelement::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_domelement::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domelement
Variant c_domelement::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_domnode::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domelement
Variant c_domelement::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domelement
bool c_domelement::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_domelement::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domelement
bool c_domelement::o_existsPublic(CStrRef s, int64 hash) const {
  return c_domnode::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domelement
bool c_domelement::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_domelement
Variant c_domelement::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_domelement::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domelement
Variant c_domelement::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_domnode::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domelement
Variant c_domelement::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domelement
Variant& c_domelement::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_domelement::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domelement
Variant& c_domelement::o_lvalPublic(CStrRef s, int64 hash) {
  return c_domnode::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domelement
Variant& c_domelement::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domelement
Variant c_domelement::os_constant(const char *s) {
  return c_domnode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domelement
IMPLEMENT_CLASS(domelement)
c_domelement *c_domelement::create(String a0, String a1, String a2) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2);
  return this;
}
ObjectData *c_domelement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 2);
    if (count <= 1) (t___construct(params[0]));
    else if (count == 2) (t___construct(params[0], params[1]));
    else (t___construct(params[0], params[1], params[2]));
  }
  return this;
}
void c_domelement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 2);
  if (count <= 1) (t___construct(params[0]));
  else if (count == 2) (t___construct(params[0], params[1]));
  else (t___construct(params[0], params[1], params[2]));
}
void c_domelement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else (t___construct(a0, a1, a2), null);
}
void c_domelement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_domelement::cloneImpl() {
  c_domelement *obj = NEW(c_domelement)();
  cloneSet(obj);
  return obj;
}
void c_domelement::cloneSet(c_domelement *clone) {
  c_domnode::cloneSet(clone);
}
Variant c_domelement::doGet(Variant v_name, bool error) {
  return t___get(v_name);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domelement
Variant c_domelement::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(params[0]));
        if (count == 2) return (t_c14n(params[0], params[1]));
        if (count == 3) return (t_c14n(params[0], params[1], params[2]));
        return (t_c14n(params[0], params[1], params[2], params[3]));
      }
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(params[0], params[1]));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(params[0]));
      }
      break;
    case 16:
      HASH_GUARD(0x710986B01E1A0890LL, removeattributens) {
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        return (t_removeattributens(params[0], params[1]));
      }
      break;
    case 17:
      HASH_GUARD(0x31426AC6A851EE11LL, setidattributens) {
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        return (t_setidattributens(params[0], params[1], params[2]));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(params[0]));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(params[0], params[1]));
      }
      break;
    case 22:
      HASH_GUARD(0x6F83EC29E110D616LL, setidattribute) {
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        return (t_setidattribute(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x640FA60DDC80EC18LL, getattributenodens) {
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        return (t_getattributenodens(params[0], params[1]));
      }
      break;
    case 25:
      HASH_GUARD(0x34E103E06D3F0899LL, getattributens) {
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        return (t_getattributens(params[0], params[1]));
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(params[0]));
      }
      break;
    case 47:
      HASH_GUARD(0x47B96C0FC62E1E2FLL, removeattribute) {
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        return (t_removeattribute(params[0]));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(params[0]));
        return (t_insertbefore(params[0], params[1]));
      }
      break;
    case 67:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 74:
      HASH_GUARD(0x3FFA3F55ECAB93CALL, getelementsbytagname) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(params[0]));
      }
      HASH_GUARD(0x1A9CC561CA4817CALL, getelementsbytagnamens) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(params[0], params[1]));
      }
      HASH_GUARD(0x29D272CBBC0CDA4ALL, setidattributenode) {
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        return (t_setidattributenode(params[0], params[1]));
      }
      break;
    case 79:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(params[0]));
      }
      break;
    case 81:
      HASH_GUARD(0x482E3873306253D1LL, setattributenodens) {
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        return (t_setattributenodens(params[0]));
      }
      break;
    case 85:
      HASH_GUARD(0x5EF7C3A45311D955LL, hasattributens) {
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        return (t_hasattributens(params[0], params[1]));
      }
      break;
    case 87:
      HASH_GUARD(0x62A40E71FAF19157LL, setattributens) {
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        return (t_setattributens(params[0], params[1], params[2]));
      }
      break;
    case 90:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 92:
      HASH_GUARD(0x606827EF5CF34C5CLL, setattributenode) {
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        return (t_setattributenode(params[0]));
      }
      break;
    case 93:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(params[0]));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(params[0]));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        if (count <= 1) return (t___construct(params[0]), null);
        if (count == 2) return (t___construct(params[0], params[1]), null);
        return (t___construct(params[0], params[1], params[2]), null);
      }
      break;
    case 97:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(params[0]));
      }
      break;
    case 100:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(params[0]));
      }
      break;
    case 106:
      HASH_GUARD(0x1BFDB4272EA150EALL, removeattributenode) {
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        return (t_removeattributenode(params[0]));
      }
      break;
    case 108:
      HASH_GUARD(0x6471DF8BB944FFECLL, hasattribute) {
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        return (t_hasattribute(params[0]));
      }
      break;
    case 111:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(params[0]));
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(params[0]));
        if (count == 2) return (t_c14nfile(params[0], params[1]));
        if (count == 3) return (t_c14nfile(params[0], params[1], params[2]));
        if (count == 4) return (t_c14nfile(params[0], params[1], params[2], params[3]));
        return (t_c14nfile(params[0], params[1], params[2], params[3], params[4]));
      }
      break;
    case 122:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(params[0], params[1]));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 126:
      HASH_GUARD(0x343DF562BB5AB1FELL, getattributenode) {
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        return (t_getattributenode(params[0]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domelement
Variant c_domelement::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD(0x710986B01E1A0890LL, removeattributens) {
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        return (t_removeattributens(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD(0x31426AC6A851EE11LL, setidattributens) {
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        return (t_setidattributens(a0, a1, a2));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD(0x6F83EC29E110D616LL, setidattribute) {
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        return (t_setidattribute(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD(0x640FA60DDC80EC18LL, getattributenodens) {
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 25:
      HASH_GUARD(0x34E103E06D3F0899LL, getattributens) {
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        return (t_getattributens(a0, a1));
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x47B96C0FC62E1E2FLL, removeattribute) {
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        return (t_removeattribute(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 67:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 74:
      HASH_GUARD(0x3FFA3F55ECAB93CALL, getelementsbytagname) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD(0x1A9CC561CA4817CALL, getelementsbytagnamens) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      HASH_GUARD(0x29D272CBBC0CDA4ALL, setidattributenode) {
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        return (t_setidattributenode(a0, a1));
      }
      break;
    case 79:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 81:
      HASH_GUARD(0x482E3873306253D1LL, setattributenodens) {
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        return (t_setattributenodens(a0));
      }
      break;
    case 85:
      HASH_GUARD(0x5EF7C3A45311D955LL, hasattributens) {
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        return (t_hasattributens(a0, a1));
      }
      break;
    case 87:
      HASH_GUARD(0x62A40E71FAF19157LL, setattributens) {
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 90:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 92:
      HASH_GUARD(0x606827EF5CF34C5CLL, setattributenode) {
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        return (t_setattributenode(a0));
      }
      break;
    case 93:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        return (t___construct(a0, a1, a2), null);
      }
      break;
    case 97:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 106:
      HASH_GUARD(0x1BFDB4272EA150EALL, removeattributenode) {
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        return (t_removeattributenode(a0));
      }
      break;
    case 108:
      HASH_GUARD(0x6471DF8BB944FFECLL, hasattribute) {
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        return (t_hasattribute(a0));
      }
      break;
    case 111:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 122:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 126:
      HASH_GUARD(0x343DF562BB5AB1FELL, getattributenode) {
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        return (t_getattributenode(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domelement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domelement
Variant c_domelement::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domelement
Variant c_domelement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 10:
      HASH_GUARD(0x77570221C582ED8ALL, c14n) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD(0x1D5B8B8144F4AB8ALL, setattribute) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD(0x1C51CE3C2356D08ELL, replacechild) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x26B6E00C74FA338FLL, __get) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD(0x710986B01E1A0890LL, removeattributens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributens(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD(0x31426AC6A851EE11LL, setidattributens) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributens(a0, a1, a2));
      }
      break;
    case 18:
      HASH_GUARD(0x4F615934A04E3092LL, clonenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD(0x52F3DAD783340395LL, __set) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD(0x6F83EC29E110D616LL, setidattribute) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattribute(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x58F8D846AF9E5D18LL, getlineno) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD(0x640FA60DDC80EC18LL, getattributenodens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 25:
      HASH_GUARD(0x34E103E06D3F0899LL, getattributens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributens(a0, a1));
      }
      break;
    case 40:
      HASH_GUARD(0x49F89C466612FC28LL, getattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD(0x47B96C0FC62E1E2FLL, removeattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattribute(a0));
      }
      break;
    case 49:
      HASH_GUARD(0x3CFA6EECF6F5AEB1LL, hasattributes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD(0x076FF0CF9185C433LL, insertbefore) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 67:
      HASH_GUARD(0x69797649716AE343LL, getnodepath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 74:
      HASH_GUARD(0x3FFA3F55ECAB93CALL, getelementsbytagname) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD(0x1A9CC561CA4817CALL, getelementsbytagnamens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      HASH_GUARD(0x29D272CBBC0CDA4ALL, setidattributenode) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributenode(a0, a1));
      }
      break;
    case 79:
      HASH_GUARD(0x0B44A59A023E75CFLL, appendchild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 81:
      HASH_GUARD(0x482E3873306253D1LL, setattributenodens) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenodens(a0));
      }
      break;
    case 85:
      HASH_GUARD(0x5EF7C3A45311D955LL, hasattributens) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributens(a0, a1));
      }
      break;
    case 87:
      HASH_GUARD(0x62A40E71FAF19157LL, setattributens) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 90:
      HASH_GUARD(0x11A2D4B742CB6C5ALL, normalize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 92:
      HASH_GUARD(0x606827EF5CF34C5CLL, setattributenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenode(a0));
      }
      break;
    case 93:
      HASH_GUARD(0x28D1E151A83B8F5DLL, lookupnamespaceuri) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD(0x72044C28B65364DDLL, removechild) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else return (t___construct(a0, a1, a2), null);
      }
      break;
    case 97:
      HASH_GUARD(0x599DE23996CB7D61LL, lookupprefix) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD(0x643EFC8E9378F664LL, isdefaultnamespace) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 106:
      HASH_GUARD(0x1BFDB4272EA150EALL, removeattributenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributenode(a0));
      }
      break;
    case 108:
      HASH_GUARD(0x6471DF8BB944FFECLL, hasattribute) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattribute(a0));
      }
      break;
    case 111:
      HASH_GUARD(0x102549E9CA2EC6EFLL, issamenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD(0x7F974836AACC1EF3LL, __destruct) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD(0x1D1768A6CF365A75LL, c14nfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 122:
      HASH_GUARD(0x279AA1B214B7677ALL, issupported) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD(0x5F63574EA50595FALL, haschildnodes) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 126:
      HASH_GUARD(0x343DF562BB5AB1FELL, getattributenode) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenode(a0));
      }
      break;
    default:
      break;
  }
  return c_domnode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domelement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_domnode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domelement = {
  c_domelement::os_getInit,
  c_domelement::os_get,
  c_domelement::os_lval,
  c_domelement::os_invoke,
  c_domelement::os_constant,
};
Variant get_builtin_class_var_init(const char *s, const char *var) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string_i(s);
  switch (hash & 255) {
    case 9:
      HASH_GET_CLASS_VAR_INIT(0x21EF70351574EC09LL, reflectionfunction);
      break;
    case 11:
      HASH_GET_CLASS_VAR_INIT(0x4365BE9E5A85E60BLL, domnotation);
      HASH_GET_CLASS_VAR_INIT(0x69EDCA1CC29CFE0BLL, errorexception);
      break;
    case 19:
      HASH_GET_CLASS_VAR_INIT(0x6A76B9AABB7CC713LL, simplexmlelement);
      break;
    case 21:
      HASH_GET_CLASS_VAR_INIT(0x32E5C767255D2515LL, soapfault);
      break;
    case 26:
      HASH_GET_CLASS_VAR_INIT(0x5CBA5B52C68B501ALL, domentityreference);
      break;
    case 29:
      HASH_GET_CLASS_VAR_INIT(0x35A44A5E6AE2E71DLL, reflectionclass);
      break;
    case 30:
      HASH_GET_CLASS_VAR_INIT(0x3DB8FB455A602A1ELL, datetime);
      break;
    case 43:
      HASH_GET_CLASS_VAR_INIT(0x7E66D362EAB5BF2BLL, simplexmlelementiterator);
      break;
    case 49:
      HASH_GET_CLASS_VAR_INIT(0x7A394042E7488231LL, filteriterator);
      break;
    case 50:
      HASH_GET_CLASS_VAR_INIT(0x365899865E2EAA32LL, recursiveiteratoriterator);
      break;
    case 53:
      HASH_GET_CLASS_VAR_INIT(0x7909270014376235LL, soapvar);
      break;
    case 55:
      HASH_GET_CLASS_VAR_INIT(0x7FF7A8442616EF37LL, domnodeiterator);
      break;
    case 56:
      HASH_GET_CLASS_VAR_INIT(0x672AD818DDE95538LL, reflectionexception);
      break;
    case 62:
      HASH_GET_CLASS_VAR_INIT(0x49FC1A1F7B878C3ELL, soapserver);
      break;
    case 65:
      HASH_GET_CLASS_VAR_INIT(0x227C70ED5B143841LL, outofboundsexception);
      break;
    case 68:
      HASH_GET_CLASS_VAR_INIT(0x4253D8488B734244LL, pdostatement);
      break;
    case 70:
      HASH_GET_CLASS_VAR_INIT(0x196F76C9C527B946LL, domnamednodemap);
      HASH_GET_CLASS_VAR_INIT(0x66282FC8E4EF4E46LL, badfunctioncallexception);
      break;
    case 73:
      HASH_GET_CLASS_VAR_INIT(0x5AA2EE582E0D3849LL, unexpectedvalueexception);
      break;
    case 75:
      HASH_GET_CLASS_VAR_INIT(0x4860DC2F9B0E6D4BLL, logicexception);
      break;
    case 77:
      HASH_GET_CLASS_VAR_INIT(0x164F490DAC49174DLL, domtext);
      break;
    case 78:
      HASH_GET_CLASS_VAR_INIT(0x308D1D59986A3D4ELL, soapheader);
      break;
    case 79:
      HASH_GET_CLASS_VAR_INIT(0x5BA243B9FBA7A64FLL, splobjectstorage);
      break;
    case 80:
      HASH_GET_CLASS_VAR_INIT(0x52EA111229F87A50LL, normalizer);
      break;
    case 83:
      HASH_GET_CLASS_VAR_INIT(0x02239AA5D64B1453LL, domcharacterdata);
      HASH_GET_CLASS_VAR_INIT(0x6AF83706F76A9D53LL, rangeexception);
      break;
    case 94:
      HASH_GET_CLASS_VAR_INIT(0x7754323897E8A15ELL, directoryiterator);
      break;
    case 97:
      HASH_GET_CLASS_VAR_INIT(0x70EBB2CC1FBF9761LL, domdocumenttype);
      break;
    case 98:
      HASH_GET_CLASS_VAR_INIT(0x70747A09B3523662LL, domnode);
      break;
    case 101:
      HASH_GET_CLASS_VAR_INIT(0x2FF1EF6EBB3DA065LL, xmlwriter);
      break;
    case 104:
      HASH_GET_CLASS_VAR_INIT(0x7E07B9C27FE59D68LL, domcomment);
      HASH_GET_CLASS_VAR_INIT(0x17A40D895C55D968LL, soapparam);
      break;
    case 106:
      HASH_GET_CLASS_VAR_INIT(0x6A5B99D5B1A4566ALL, domexception);
      break;
    case 107:
      HASH_GET_CLASS_VAR_INIT(0x3CAE91CFA2AAD16BLL, lengthexception);
      break;
    case 115:
      HASH_GET_CLASS_VAR_INIT(0x3D5870E53BF89873LL, arrayiterator);
      HASH_GET_CLASS_VAR_INIT(0x0B61E0BFCFA06573LL, reflectionextension);
      break;
    case 116:
      HASH_GET_CLASS_VAR_INIT(0x126B0D414E0AFD74LL, concurrentvector);
      break;
    case 117:
      HASH_GET_CLASS_VAR_INIT(0x085A4F6FD393D475LL, invalidargumentexception);
      break;
    case 122:
      HASH_GET_CLASS_VAR_INIT(0x41A9F7D81254DD7ALL, reflectionobject);
      break;
    case 125:
      HASH_GET_CLASS_VAR_INIT(0x7AD161197633B87DLL, domdocumentfragment);
      HASH_GET_CLASS_VAR_INIT(0x2E899D2A2572EF7DLL, sqlite3result);
      break;
    case 128:
      HASH_GET_CLASS_VAR_INIT(0x59B3EFD1CD987F80LL, domprocessinginstruction);
      break;
    case 130:
      HASH_GET_CLASS_VAR_INIT(0x33BD46E935281082LL, reflectionfunctionabstract);
      break;
    case 131:
      HASH_GET_CLASS_VAR_INIT(0x24DE53FD7D3E8383LL, datetimezone);
      break;
    case 132:
      HASH_GET_CLASS_VAR_INIT(0x70D4A29DE6A7BA84LL, domainexception);
      break;
    case 143:
      HASH_GET_CLASS_VAR_INIT(0x34C95AF311506C8FLL, directory);
      break;
    case 144:
      HASH_GET_CLASS_VAR_INIT(0x06335FF83CDEA590LL, badmethodcallexception);
      break;
    case 147:
      HASH_GET_CLASS_VAR_INIT(0x2E7081C468A05993LL, reflectionparameter);
      break;
    case 148:
      HASH_GET_CLASS_VAR_INIT(0x6FFDF8DF15CABE94LL, domcdatasection);
      HASH_GET_CLASS_VAR_INIT(0x6576EACCCE24D694LL, __php_incomplete_class);
      HASH_GET_CLASS_VAR_INIT(0x47D93E6F80B66A94LL, exception);
      break;
    case 152:
      HASH_GET_CLASS_VAR_INIT(0x3CEBA108A1BAB998LL, pear_error);
      break;
    case 167:
      HASH_GET_CLASS_VAR_INIT(0x71089C29FE923FA7LL, splfileinfo);
      break;
    case 168:
      HASH_GET_CLASS_VAR_INIT(0x7D46DB2E09C6DBA8LL, domxpath);
      break;
    case 169:
      HASH_GET_CLASS_VAR_INIT(0x1D35C3EFD00E11A9LL, sqlite3);
      break;
    case 173:
      HASH_GET_CLASS_VAR_INIT(0x0A34015F67C804ADLL, pdo);
      break;
    case 175:
      HASH_GET_CLASS_VAR_INIT(0x2E650138BA043AAFLL, domdocument);
      break;
    case 176:
      HASH_GET_CLASS_VAR_INIT(0x43BBC8F6F28E44B0LL, reflectionmethod);
      break;
    case 177:
      HASH_GET_CLASS_VAR_INIT(0x6DD772FA3B20B8B1LL, domnodelist);
      break;
    case 189:
      HASH_GET_CLASS_VAR_INIT(0x5D8785ACD19F77BDLL, pdoexception);
      break;
    case 195:
      HASH_GET_CLASS_VAR_INIT(0x40B3C44077F5DDC3LL, domelement);
      break;
    case 200:
      HASH_GET_CLASS_VAR_INIT(0x2E363D51549781C8LL, appenditerator);
      break;
    case 203:
      HASH_GET_CLASS_VAR_INIT(0x253AC17234FC8CCBLL, libxmlerror);
      break;
    case 210:
      HASH_GET_CLASS_VAR_INIT(0x52E5CC58B841AED2LL, sqlite3stmt);
      HASH_GET_CLASS_VAR_INIT(0x297ECCC7A259EDD2LL, splfileobject);
      break;
    case 212:
      HASH_GET_CLASS_VAR_INIT(0x5E623FEAF7B068D4LL, underflowexception);
      break;
    case 216:
      HASH_GET_CLASS_VAR_INIT(0x464D3427431A6ED8LL, recursivedirectoryiterator);
      break;
    case 217:
      HASH_GET_CLASS_VAR_INIT(0x0E4CCE95F6A727D9LL, overflowexception);
      break;
    case 218:
      HASH_GET_CLASS_VAR_INIT(0x7A52EBE538182BDALL, soapclient);
      break;
    case 220:
      HASH_GET_CLASS_VAR_INIT(0x1078CB3118A8B3DCLL, runtimeexception);
      break;
    case 228:
      HASH_GET_CLASS_VAR_INIT(0x75AA2571BDB659E4LL, reflectionproperty);
      break;
    case 244:
      HASH_GET_CLASS_VAR_INIT(0x297174231D4912F4LL, domattr);
      break;
    case 246:
      HASH_GET_CLASS_VAR_INIT(0x1D1BA0A732290FF6LL, concurrenthash);
      break;
    case 247:
      HASH_GET_CLASS_VAR_INIT(0x3D69936178BA13F7LL, stdclass);
      break;
    case 252:
      HASH_GET_CLASS_VAR_INIT(0x622D4DF07E2A01FCLL, outofrangeexception);
      break;
    case 253:
      HASH_GET_CLASS_VAR_INIT(0x74419B70A46387FDLL, domimplementation);
      break;
    case 255:
      HASH_GET_CLASS_VAR_INIT(0x624835B2D74B86FFLL, domentity);
      break;
    default:
      break;
  }
  return throw_missing_class(s);
}
Object create_builtin_object(const char *s, CArrRef params, bool init /* = true */,ObjectData* root /* = NULL*/) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string_i(s);
  switch (hash & 255) {
    case 9:
      HASH_CREATE_OBJECT(0x21EF70351574EC09LL, reflectionfunction);
      break;
    case 11:
      HASH_CREATE_OBJECT(0x4365BE9E5A85E60BLL, domnotation);
      HASH_CREATE_OBJECT(0x69EDCA1CC29CFE0BLL, errorexception);
      break;
    case 19:
      HASH_CREATE_OBJECT(0x6A76B9AABB7CC713LL, simplexmlelement);
      break;
    case 21:
      HASH_CREATE_OBJECT(0x32E5C767255D2515LL, soapfault);
      break;
    case 26:
      HASH_CREATE_OBJECT(0x5CBA5B52C68B501ALL, domentityreference);
      break;
    case 29:
      HASH_CREATE_OBJECT(0x35A44A5E6AE2E71DLL, reflectionclass);
      break;
    case 30:
      HASH_CREATE_OBJECT(0x3DB8FB455A602A1ELL, datetime);
      break;
    case 43:
      HASH_CREATE_OBJECT(0x7E66D362EAB5BF2BLL, simplexmlelementiterator);
      break;
    case 49:
      HASH_CREATE_OBJECT(0x7A394042E7488231LL, filteriterator);
      break;
    case 50:
      HASH_CREATE_OBJECT(0x365899865E2EAA32LL, recursiveiteratoriterator);
      break;
    case 53:
      HASH_CREATE_OBJECT(0x7909270014376235LL, soapvar);
      break;
    case 55:
      HASH_CREATE_OBJECT(0x7FF7A8442616EF37LL, domnodeiterator);
      break;
    case 56:
      HASH_CREATE_OBJECT(0x672AD818DDE95538LL, reflectionexception);
      break;
    case 62:
      HASH_CREATE_OBJECT(0x49FC1A1F7B878C3ELL, soapserver);
      break;
    case 65:
      HASH_CREATE_OBJECT(0x227C70ED5B143841LL, outofboundsexception);
      break;
    case 68:
      HASH_CREATE_OBJECT(0x4253D8488B734244LL, pdostatement);
      break;
    case 70:
      HASH_CREATE_OBJECT(0x196F76C9C527B946LL, domnamednodemap);
      HASH_CREATE_OBJECT(0x66282FC8E4EF4E46LL, badfunctioncallexception);
      break;
    case 73:
      HASH_CREATE_OBJECT(0x5AA2EE582E0D3849LL, unexpectedvalueexception);
      break;
    case 75:
      HASH_CREATE_OBJECT(0x4860DC2F9B0E6D4BLL, logicexception);
      break;
    case 77:
      HASH_CREATE_OBJECT(0x164F490DAC49174DLL, domtext);
      break;
    case 78:
      HASH_CREATE_OBJECT(0x308D1D59986A3D4ELL, soapheader);
      break;
    case 79:
      HASH_CREATE_OBJECT(0x5BA243B9FBA7A64FLL, splobjectstorage);
      break;
    case 80:
      HASH_CREATE_OBJECT(0x52EA111229F87A50LL, normalizer);
      break;
    case 83:
      HASH_CREATE_OBJECT(0x02239AA5D64B1453LL, domcharacterdata);
      HASH_CREATE_OBJECT(0x6AF83706F76A9D53LL, rangeexception);
      break;
    case 94:
      HASH_CREATE_OBJECT(0x7754323897E8A15ELL, directoryiterator);
      break;
    case 97:
      HASH_CREATE_OBJECT(0x70EBB2CC1FBF9761LL, domdocumenttype);
      break;
    case 98:
      HASH_CREATE_OBJECT(0x70747A09B3523662LL, domnode);
      break;
    case 101:
      HASH_CREATE_OBJECT(0x2FF1EF6EBB3DA065LL, xmlwriter);
      break;
    case 104:
      HASH_CREATE_OBJECT(0x7E07B9C27FE59D68LL, domcomment);
      HASH_CREATE_OBJECT(0x17A40D895C55D968LL, soapparam);
      break;
    case 106:
      HASH_CREATE_OBJECT(0x6A5B99D5B1A4566ALL, domexception);
      break;
    case 107:
      HASH_CREATE_OBJECT(0x3CAE91CFA2AAD16BLL, lengthexception);
      break;
    case 115:
      HASH_CREATE_OBJECT(0x3D5870E53BF89873LL, arrayiterator);
      HASH_CREATE_OBJECT(0x0B61E0BFCFA06573LL, reflectionextension);
      break;
    case 116:
      HASH_CREATE_OBJECT(0x126B0D414E0AFD74LL, concurrentvector);
      break;
    case 117:
      HASH_CREATE_OBJECT(0x085A4F6FD393D475LL, invalidargumentexception);
      break;
    case 122:
      HASH_CREATE_OBJECT(0x41A9F7D81254DD7ALL, reflectionobject);
      break;
    case 125:
      HASH_CREATE_OBJECT(0x7AD161197633B87DLL, domdocumentfragment);
      HASH_CREATE_OBJECT(0x2E899D2A2572EF7DLL, sqlite3result);
      break;
    case 128:
      HASH_CREATE_OBJECT(0x59B3EFD1CD987F80LL, domprocessinginstruction);
      break;
    case 130:
      HASH_CREATE_OBJECT(0x33BD46E935281082LL, reflectionfunctionabstract);
      break;
    case 131:
      HASH_CREATE_OBJECT(0x24DE53FD7D3E8383LL, datetimezone);
      break;
    case 132:
      HASH_CREATE_OBJECT(0x70D4A29DE6A7BA84LL, domainexception);
      break;
    case 143:
      HASH_CREATE_OBJECT(0x34C95AF311506C8FLL, directory);
      break;
    case 144:
      HASH_CREATE_OBJECT(0x06335FF83CDEA590LL, badmethodcallexception);
      break;
    case 147:
      HASH_CREATE_OBJECT(0x2E7081C468A05993LL, reflectionparameter);
      break;
    case 148:
      HASH_CREATE_OBJECT(0x6FFDF8DF15CABE94LL, domcdatasection);
      HASH_CREATE_OBJECT(0x6576EACCCE24D694LL, __php_incomplete_class);
      HASH_CREATE_OBJECT(0x47D93E6F80B66A94LL, exception);
      break;
    case 152:
      HASH_CREATE_OBJECT(0x3CEBA108A1BAB998LL, pear_error);
      break;
    case 167:
      HASH_CREATE_OBJECT(0x71089C29FE923FA7LL, splfileinfo);
      break;
    case 168:
      HASH_CREATE_OBJECT(0x7D46DB2E09C6DBA8LL, domxpath);
      break;
    case 169:
      HASH_CREATE_OBJECT(0x1D35C3EFD00E11A9LL, sqlite3);
      break;
    case 173:
      HASH_CREATE_OBJECT(0x0A34015F67C804ADLL, pdo);
      break;
    case 175:
      HASH_CREATE_OBJECT(0x2E650138BA043AAFLL, domdocument);
      break;
    case 176:
      HASH_CREATE_OBJECT(0x43BBC8F6F28E44B0LL, reflectionmethod);
      break;
    case 177:
      HASH_CREATE_OBJECT(0x6DD772FA3B20B8B1LL, domnodelist);
      break;
    case 189:
      HASH_CREATE_OBJECT(0x5D8785ACD19F77BDLL, pdoexception);
      break;
    case 195:
      HASH_CREATE_OBJECT(0x40B3C44077F5DDC3LL, domelement);
      break;
    case 200:
      HASH_CREATE_OBJECT(0x2E363D51549781C8LL, appenditerator);
      break;
    case 203:
      HASH_CREATE_OBJECT(0x253AC17234FC8CCBLL, libxmlerror);
      break;
    case 210:
      HASH_CREATE_OBJECT(0x52E5CC58B841AED2LL, sqlite3stmt);
      HASH_CREATE_OBJECT(0x297ECCC7A259EDD2LL, splfileobject);
      break;
    case 212:
      HASH_CREATE_OBJECT(0x5E623FEAF7B068D4LL, underflowexception);
      break;
    case 216:
      HASH_CREATE_OBJECT(0x464D3427431A6ED8LL, recursivedirectoryiterator);
      break;
    case 217:
      HASH_CREATE_OBJECT(0x0E4CCE95F6A727D9LL, overflowexception);
      break;
    case 218:
      HASH_CREATE_OBJECT(0x7A52EBE538182BDALL, soapclient);
      break;
    case 220:
      HASH_CREATE_OBJECT(0x1078CB3118A8B3DCLL, runtimeexception);
      break;
    case 228:
      HASH_CREATE_OBJECT(0x75AA2571BDB659E4LL, reflectionproperty);
      break;
    case 244:
      HASH_CREATE_OBJECT(0x297174231D4912F4LL, domattr);
      break;
    case 246:
      HASH_CREATE_OBJECT(0x1D1BA0A732290FF6LL, concurrenthash);
      break;
    case 247:
      HASH_CREATE_OBJECT(0x3D69936178BA13F7LL, stdclass);
      break;
    case 252:
      HASH_CREATE_OBJECT(0x622D4DF07E2A01FCLL, outofrangeexception);
      break;
    case 253:
      HASH_CREATE_OBJECT(0x74419B70A46387FDLL, domimplementation);
      break;
    case 255:
      HASH_CREATE_OBJECT(0x624835B2D74B86FFLL, domentity);
      break;
    default:
      break;
  }
  return throw_missing_class(s);
}
Variant invoke_builtin_static_method(const char *s, const char *method, CArrRef params, bool fatal) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string_i(s);
  switch (hash & 255) {
    case 9:
      HASH_INVOKE_STATIC_METHOD(0x21EF70351574EC09LL, reflectionfunction);
      break;
    case 11:
      HASH_INVOKE_STATIC_METHOD(0x4365BE9E5A85E60BLL, domnotation);
      HASH_INVOKE_STATIC_METHOD(0x69EDCA1CC29CFE0BLL, errorexception);
      break;
    case 19:
      HASH_INVOKE_STATIC_METHOD(0x6A76B9AABB7CC713LL, simplexmlelement);
      break;
    case 21:
      HASH_INVOKE_STATIC_METHOD(0x32E5C767255D2515LL, soapfault);
      break;
    case 26:
      HASH_INVOKE_STATIC_METHOD(0x5CBA5B52C68B501ALL, domentityreference);
      break;
    case 29:
      HASH_INVOKE_STATIC_METHOD(0x35A44A5E6AE2E71DLL, reflectionclass);
      break;
    case 30:
      HASH_INVOKE_STATIC_METHOD(0x3DB8FB455A602A1ELL, datetime);
      break;
    case 43:
      HASH_INVOKE_STATIC_METHOD(0x7E66D362EAB5BF2BLL, simplexmlelementiterator);
      break;
    case 49:
      HASH_INVOKE_STATIC_METHOD(0x7A394042E7488231LL, filteriterator);
      break;
    case 50:
      HASH_INVOKE_STATIC_METHOD(0x365899865E2EAA32LL, recursiveiteratoriterator);
      break;
    case 53:
      HASH_INVOKE_STATIC_METHOD(0x7909270014376235LL, soapvar);
      break;
    case 55:
      HASH_INVOKE_STATIC_METHOD(0x7FF7A8442616EF37LL, domnodeiterator);
      break;
    case 56:
      HASH_INVOKE_STATIC_METHOD(0x672AD818DDE95538LL, reflectionexception);
      break;
    case 62:
      HASH_INVOKE_STATIC_METHOD(0x49FC1A1F7B878C3ELL, soapserver);
      break;
    case 65:
      HASH_INVOKE_STATIC_METHOD(0x227C70ED5B143841LL, outofboundsexception);
      break;
    case 68:
      HASH_INVOKE_STATIC_METHOD(0x4253D8488B734244LL, pdostatement);
      break;
    case 70:
      HASH_INVOKE_STATIC_METHOD(0x196F76C9C527B946LL, domnamednodemap);
      HASH_INVOKE_STATIC_METHOD(0x66282FC8E4EF4E46LL, badfunctioncallexception);
      break;
    case 73:
      HASH_INVOKE_STATIC_METHOD(0x5AA2EE582E0D3849LL, unexpectedvalueexception);
      break;
    case 75:
      HASH_INVOKE_STATIC_METHOD(0x4860DC2F9B0E6D4BLL, logicexception);
      break;
    case 77:
      HASH_INVOKE_STATIC_METHOD(0x164F490DAC49174DLL, domtext);
      break;
    case 78:
      HASH_INVOKE_STATIC_METHOD(0x308D1D59986A3D4ELL, soapheader);
      break;
    case 79:
      HASH_INVOKE_STATIC_METHOD(0x5BA243B9FBA7A64FLL, splobjectstorage);
      break;
    case 80:
      HASH_INVOKE_STATIC_METHOD(0x52EA111229F87A50LL, normalizer);
      break;
    case 83:
      HASH_INVOKE_STATIC_METHOD(0x02239AA5D64B1453LL, domcharacterdata);
      HASH_INVOKE_STATIC_METHOD(0x6AF83706F76A9D53LL, rangeexception);
      break;
    case 94:
      HASH_INVOKE_STATIC_METHOD(0x7754323897E8A15ELL, directoryiterator);
      break;
    case 97:
      HASH_INVOKE_STATIC_METHOD(0x70EBB2CC1FBF9761LL, domdocumenttype);
      break;
    case 98:
      HASH_INVOKE_STATIC_METHOD(0x70747A09B3523662LL, domnode);
      break;
    case 101:
      HASH_INVOKE_STATIC_METHOD(0x2FF1EF6EBB3DA065LL, xmlwriter);
      break;
    case 104:
      HASH_INVOKE_STATIC_METHOD(0x7E07B9C27FE59D68LL, domcomment);
      HASH_INVOKE_STATIC_METHOD(0x17A40D895C55D968LL, soapparam);
      break;
    case 106:
      HASH_INVOKE_STATIC_METHOD(0x6A5B99D5B1A4566ALL, domexception);
      break;
    case 107:
      HASH_INVOKE_STATIC_METHOD(0x3CAE91CFA2AAD16BLL, lengthexception);
      break;
    case 115:
      HASH_INVOKE_STATIC_METHOD(0x3D5870E53BF89873LL, arrayiterator);
      HASH_INVOKE_STATIC_METHOD(0x0B61E0BFCFA06573LL, reflectionextension);
      break;
    case 116:
      HASH_INVOKE_STATIC_METHOD(0x126B0D414E0AFD74LL, concurrentvector);
      break;
    case 117:
      HASH_INVOKE_STATIC_METHOD(0x085A4F6FD393D475LL, invalidargumentexception);
      break;
    case 122:
      HASH_INVOKE_STATIC_METHOD(0x41A9F7D81254DD7ALL, reflectionobject);
      break;
    case 125:
      HASH_INVOKE_STATIC_METHOD(0x7AD161197633B87DLL, domdocumentfragment);
      HASH_INVOKE_STATIC_METHOD(0x2E899D2A2572EF7DLL, sqlite3result);
      break;
    case 128:
      HASH_INVOKE_STATIC_METHOD(0x59B3EFD1CD987F80LL, domprocessinginstruction);
      break;
    case 130:
      HASH_INVOKE_STATIC_METHOD(0x33BD46E935281082LL, reflectionfunctionabstract);
      break;
    case 131:
      HASH_INVOKE_STATIC_METHOD(0x24DE53FD7D3E8383LL, datetimezone);
      break;
    case 132:
      HASH_INVOKE_STATIC_METHOD(0x70D4A29DE6A7BA84LL, domainexception);
      break;
    case 143:
      HASH_INVOKE_STATIC_METHOD(0x34C95AF311506C8FLL, directory);
      break;
    case 144:
      HASH_INVOKE_STATIC_METHOD(0x06335FF83CDEA590LL, badmethodcallexception);
      break;
    case 147:
      HASH_INVOKE_STATIC_METHOD(0x2E7081C468A05993LL, reflectionparameter);
      break;
    case 148:
      HASH_INVOKE_STATIC_METHOD(0x6FFDF8DF15CABE94LL, domcdatasection);
      HASH_INVOKE_STATIC_METHOD(0x6576EACCCE24D694LL, __php_incomplete_class);
      HASH_INVOKE_STATIC_METHOD(0x47D93E6F80B66A94LL, exception);
      break;
    case 152:
      HASH_INVOKE_STATIC_METHOD(0x3CEBA108A1BAB998LL, pear_error);
      break;
    case 167:
      HASH_INVOKE_STATIC_METHOD(0x71089C29FE923FA7LL, splfileinfo);
      break;
    case 168:
      HASH_INVOKE_STATIC_METHOD(0x7D46DB2E09C6DBA8LL, domxpath);
      break;
    case 169:
      HASH_INVOKE_STATIC_METHOD(0x1D35C3EFD00E11A9LL, sqlite3);
      break;
    case 173:
      HASH_INVOKE_STATIC_METHOD(0x0A34015F67C804ADLL, pdo);
      break;
    case 175:
      HASH_INVOKE_STATIC_METHOD(0x2E650138BA043AAFLL, domdocument);
      break;
    case 176:
      HASH_INVOKE_STATIC_METHOD(0x43BBC8F6F28E44B0LL, reflectionmethod);
      break;
    case 177:
      HASH_INVOKE_STATIC_METHOD(0x6DD772FA3B20B8B1LL, domnodelist);
      break;
    case 189:
      HASH_INVOKE_STATIC_METHOD(0x5D8785ACD19F77BDLL, pdoexception);
      break;
    case 195:
      HASH_INVOKE_STATIC_METHOD(0x40B3C44077F5DDC3LL, domelement);
      break;
    case 200:
      HASH_INVOKE_STATIC_METHOD(0x2E363D51549781C8LL, appenditerator);
      break;
    case 203:
      HASH_INVOKE_STATIC_METHOD(0x253AC17234FC8CCBLL, libxmlerror);
      break;
    case 210:
      HASH_INVOKE_STATIC_METHOD(0x52E5CC58B841AED2LL, sqlite3stmt);
      HASH_INVOKE_STATIC_METHOD(0x297ECCC7A259EDD2LL, splfileobject);
      break;
    case 212:
      HASH_INVOKE_STATIC_METHOD(0x5E623FEAF7B068D4LL, underflowexception);
      break;
    case 216:
      HASH_INVOKE_STATIC_METHOD(0x464D3427431A6ED8LL, recursivedirectoryiterator);
      break;
    case 217:
      HASH_INVOKE_STATIC_METHOD(0x0E4CCE95F6A727D9LL, overflowexception);
      break;
    case 218:
      HASH_INVOKE_STATIC_METHOD(0x7A52EBE538182BDALL, soapclient);
      break;
    case 220:
      HASH_INVOKE_STATIC_METHOD(0x1078CB3118A8B3DCLL, runtimeexception);
      break;
    case 228:
      HASH_INVOKE_STATIC_METHOD(0x75AA2571BDB659E4LL, reflectionproperty);
      break;
    case 244:
      HASH_INVOKE_STATIC_METHOD(0x297174231D4912F4LL, domattr);
      break;
    case 246:
      HASH_INVOKE_STATIC_METHOD(0x1D1BA0A732290FF6LL, concurrenthash);
      break;
    case 247:
      HASH_INVOKE_STATIC_METHOD(0x3D69936178BA13F7LL, stdclass);
      break;
    case 252:
      HASH_INVOKE_STATIC_METHOD(0x622D4DF07E2A01FCLL, outofrangeexception);
      break;
    case 253:
      HASH_INVOKE_STATIC_METHOD(0x74419B70A46387FDLL, domimplementation);
      break;
    case 255:
      HASH_INVOKE_STATIC_METHOD(0x624835B2D74B86FFLL, domentity);
      break;
    default:
      break;
  }
  if (fatal) {
    return throw_missing_class(s);
  } else {
    raise_warning("call_user_func to non-existent class's method %s::%s", s, method);
    return false;
  }
}
Variant get_builtin_static_property(const char *s, const char *prop) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string_i(s);
  switch (hash & 255) {
    case 9:
      HASH_GET_STATIC_PROPERTY(0x21EF70351574EC09LL, reflectionfunction);
      break;
    case 11:
      HASH_GET_STATIC_PROPERTY(0x4365BE9E5A85E60BLL, domnotation);
      HASH_GET_STATIC_PROPERTY(0x69EDCA1CC29CFE0BLL, errorexception);
      break;
    case 19:
      HASH_GET_STATIC_PROPERTY(0x6A76B9AABB7CC713LL, simplexmlelement);
      break;
    case 21:
      HASH_GET_STATIC_PROPERTY(0x32E5C767255D2515LL, soapfault);
      break;
    case 26:
      HASH_GET_STATIC_PROPERTY(0x5CBA5B52C68B501ALL, domentityreference);
      break;
    case 29:
      HASH_GET_STATIC_PROPERTY(0x35A44A5E6AE2E71DLL, reflectionclass);
      break;
    case 30:
      HASH_GET_STATIC_PROPERTY(0x3DB8FB455A602A1ELL, datetime);
      break;
    case 43:
      HASH_GET_STATIC_PROPERTY(0x7E66D362EAB5BF2BLL, simplexmlelementiterator);
      break;
    case 49:
      HASH_GET_STATIC_PROPERTY(0x7A394042E7488231LL, filteriterator);
      break;
    case 50:
      HASH_GET_STATIC_PROPERTY(0x365899865E2EAA32LL, recursiveiteratoriterator);
      break;
    case 53:
      HASH_GET_STATIC_PROPERTY(0x7909270014376235LL, soapvar);
      break;
    case 55:
      HASH_GET_STATIC_PROPERTY(0x7FF7A8442616EF37LL, domnodeiterator);
      break;
    case 56:
      HASH_GET_STATIC_PROPERTY(0x672AD818DDE95538LL, reflectionexception);
      break;
    case 62:
      HASH_GET_STATIC_PROPERTY(0x49FC1A1F7B878C3ELL, soapserver);
      break;
    case 65:
      HASH_GET_STATIC_PROPERTY(0x227C70ED5B143841LL, outofboundsexception);
      break;
    case 68:
      HASH_GET_STATIC_PROPERTY(0x4253D8488B734244LL, pdostatement);
      break;
    case 70:
      HASH_GET_STATIC_PROPERTY(0x196F76C9C527B946LL, domnamednodemap);
      HASH_GET_STATIC_PROPERTY(0x66282FC8E4EF4E46LL, badfunctioncallexception);
      break;
    case 73:
      HASH_GET_STATIC_PROPERTY(0x5AA2EE582E0D3849LL, unexpectedvalueexception);
      break;
    case 75:
      HASH_GET_STATIC_PROPERTY(0x4860DC2F9B0E6D4BLL, logicexception);
      break;
    case 77:
      HASH_GET_STATIC_PROPERTY(0x164F490DAC49174DLL, domtext);
      break;
    case 78:
      HASH_GET_STATIC_PROPERTY(0x308D1D59986A3D4ELL, soapheader);
      break;
    case 79:
      HASH_GET_STATIC_PROPERTY(0x5BA243B9FBA7A64FLL, splobjectstorage);
      break;
    case 80:
      HASH_GET_STATIC_PROPERTY(0x52EA111229F87A50LL, normalizer);
      break;
    case 83:
      HASH_GET_STATIC_PROPERTY(0x02239AA5D64B1453LL, domcharacterdata);
      HASH_GET_STATIC_PROPERTY(0x6AF83706F76A9D53LL, rangeexception);
      break;
    case 94:
      HASH_GET_STATIC_PROPERTY(0x7754323897E8A15ELL, directoryiterator);
      break;
    case 97:
      HASH_GET_STATIC_PROPERTY(0x70EBB2CC1FBF9761LL, domdocumenttype);
      break;
    case 98:
      HASH_GET_STATIC_PROPERTY(0x70747A09B3523662LL, domnode);
      break;
    case 101:
      HASH_GET_STATIC_PROPERTY(0x2FF1EF6EBB3DA065LL, xmlwriter);
      break;
    case 104:
      HASH_GET_STATIC_PROPERTY(0x7E07B9C27FE59D68LL, domcomment);
      HASH_GET_STATIC_PROPERTY(0x17A40D895C55D968LL, soapparam);
      break;
    case 106:
      HASH_GET_STATIC_PROPERTY(0x6A5B99D5B1A4566ALL, domexception);
      break;
    case 107:
      HASH_GET_STATIC_PROPERTY(0x3CAE91CFA2AAD16BLL, lengthexception);
      break;
    case 115:
      HASH_GET_STATIC_PROPERTY(0x3D5870E53BF89873LL, arrayiterator);
      HASH_GET_STATIC_PROPERTY(0x0B61E0BFCFA06573LL, reflectionextension);
      break;
    case 116:
      HASH_GET_STATIC_PROPERTY(0x126B0D414E0AFD74LL, concurrentvector);
      break;
    case 117:
      HASH_GET_STATIC_PROPERTY(0x085A4F6FD393D475LL, invalidargumentexception);
      break;
    case 122:
      HASH_GET_STATIC_PROPERTY(0x41A9F7D81254DD7ALL, reflectionobject);
      break;
    case 125:
      HASH_GET_STATIC_PROPERTY(0x7AD161197633B87DLL, domdocumentfragment);
      HASH_GET_STATIC_PROPERTY(0x2E899D2A2572EF7DLL, sqlite3result);
      break;
    case 128:
      HASH_GET_STATIC_PROPERTY(0x59B3EFD1CD987F80LL, domprocessinginstruction);
      break;
    case 130:
      HASH_GET_STATIC_PROPERTY(0x33BD46E935281082LL, reflectionfunctionabstract);
      break;
    case 131:
      HASH_GET_STATIC_PROPERTY(0x24DE53FD7D3E8383LL, datetimezone);
      break;
    case 132:
      HASH_GET_STATIC_PROPERTY(0x70D4A29DE6A7BA84LL, domainexception);
      break;
    case 143:
      HASH_GET_STATIC_PROPERTY(0x34C95AF311506C8FLL, directory);
      break;
    case 144:
      HASH_GET_STATIC_PROPERTY(0x06335FF83CDEA590LL, badmethodcallexception);
      break;
    case 147:
      HASH_GET_STATIC_PROPERTY(0x2E7081C468A05993LL, reflectionparameter);
      break;
    case 148:
      HASH_GET_STATIC_PROPERTY(0x6FFDF8DF15CABE94LL, domcdatasection);
      HASH_GET_STATIC_PROPERTY(0x6576EACCCE24D694LL, __php_incomplete_class);
      HASH_GET_STATIC_PROPERTY(0x47D93E6F80B66A94LL, exception);
      break;
    case 152:
      HASH_GET_STATIC_PROPERTY(0x3CEBA108A1BAB998LL, pear_error);
      break;
    case 167:
      HASH_GET_STATIC_PROPERTY(0x71089C29FE923FA7LL, splfileinfo);
      break;
    case 168:
      HASH_GET_STATIC_PROPERTY(0x7D46DB2E09C6DBA8LL, domxpath);
      break;
    case 169:
      HASH_GET_STATIC_PROPERTY(0x1D35C3EFD00E11A9LL, sqlite3);
      break;
    case 173:
      HASH_GET_STATIC_PROPERTY(0x0A34015F67C804ADLL, pdo);
      break;
    case 175:
      HASH_GET_STATIC_PROPERTY(0x2E650138BA043AAFLL, domdocument);
      break;
    case 176:
      HASH_GET_STATIC_PROPERTY(0x43BBC8F6F28E44B0LL, reflectionmethod);
      break;
    case 177:
      HASH_GET_STATIC_PROPERTY(0x6DD772FA3B20B8B1LL, domnodelist);
      break;
    case 189:
      HASH_GET_STATIC_PROPERTY(0x5D8785ACD19F77BDLL, pdoexception);
      break;
    case 195:
      HASH_GET_STATIC_PROPERTY(0x40B3C44077F5DDC3LL, domelement);
      break;
    case 200:
      HASH_GET_STATIC_PROPERTY(0x2E363D51549781C8LL, appenditerator);
      break;
    case 203:
      HASH_GET_STATIC_PROPERTY(0x253AC17234FC8CCBLL, libxmlerror);
      break;
    case 210:
      HASH_GET_STATIC_PROPERTY(0x52E5CC58B841AED2LL, sqlite3stmt);
      HASH_GET_STATIC_PROPERTY(0x297ECCC7A259EDD2LL, splfileobject);
      break;
    case 212:
      HASH_GET_STATIC_PROPERTY(0x5E623FEAF7B068D4LL, underflowexception);
      break;
    case 216:
      HASH_GET_STATIC_PROPERTY(0x464D3427431A6ED8LL, recursivedirectoryiterator);
      break;
    case 217:
      HASH_GET_STATIC_PROPERTY(0x0E4CCE95F6A727D9LL, overflowexception);
      break;
    case 218:
      HASH_GET_STATIC_PROPERTY(0x7A52EBE538182BDALL, soapclient);
      break;
    case 220:
      HASH_GET_STATIC_PROPERTY(0x1078CB3118A8B3DCLL, runtimeexception);
      break;
    case 228:
      HASH_GET_STATIC_PROPERTY(0x75AA2571BDB659E4LL, reflectionproperty);
      break;
    case 244:
      HASH_GET_STATIC_PROPERTY(0x297174231D4912F4LL, domattr);
      break;
    case 246:
      HASH_GET_STATIC_PROPERTY(0x1D1BA0A732290FF6LL, concurrenthash);
      break;
    case 247:
      HASH_GET_STATIC_PROPERTY(0x3D69936178BA13F7LL, stdclass);
      break;
    case 252:
      HASH_GET_STATIC_PROPERTY(0x622D4DF07E2A01FCLL, outofrangeexception);
      break;
    case 253:
      HASH_GET_STATIC_PROPERTY(0x74419B70A46387FDLL, domimplementation);
      break;
    case 255:
      HASH_GET_STATIC_PROPERTY(0x624835B2D74B86FFLL, domentity);
      break;
    default:
      break;
  }
  return null;
}
Variant *get_builtin_static_property_lv(const char *s, const char *prop) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string_i(s);
  switch (hash & 255) {
    case 9:
      HASH_GET_STATIC_PROPERTY_LV(0x21EF70351574EC09LL, reflectionfunction);
      break;
    case 11:
      HASH_GET_STATIC_PROPERTY_LV(0x4365BE9E5A85E60BLL, domnotation);
      HASH_GET_STATIC_PROPERTY_LV(0x69EDCA1CC29CFE0BLL, errorexception);
      break;
    case 19:
      HASH_GET_STATIC_PROPERTY_LV(0x6A76B9AABB7CC713LL, simplexmlelement);
      break;
    case 21:
      HASH_GET_STATIC_PROPERTY_LV(0x32E5C767255D2515LL, soapfault);
      break;
    case 26:
      HASH_GET_STATIC_PROPERTY_LV(0x5CBA5B52C68B501ALL, domentityreference);
      break;
    case 29:
      HASH_GET_STATIC_PROPERTY_LV(0x35A44A5E6AE2E71DLL, reflectionclass);
      break;
    case 30:
      HASH_GET_STATIC_PROPERTY_LV(0x3DB8FB455A602A1ELL, datetime);
      break;
    case 43:
      HASH_GET_STATIC_PROPERTY_LV(0x7E66D362EAB5BF2BLL, simplexmlelementiterator);
      break;
    case 49:
      HASH_GET_STATIC_PROPERTY_LV(0x7A394042E7488231LL, filteriterator);
      break;
    case 50:
      HASH_GET_STATIC_PROPERTY_LV(0x365899865E2EAA32LL, recursiveiteratoriterator);
      break;
    case 53:
      HASH_GET_STATIC_PROPERTY_LV(0x7909270014376235LL, soapvar);
      break;
    case 55:
      HASH_GET_STATIC_PROPERTY_LV(0x7FF7A8442616EF37LL, domnodeiterator);
      break;
    case 56:
      HASH_GET_STATIC_PROPERTY_LV(0x672AD818DDE95538LL, reflectionexception);
      break;
    case 62:
      HASH_GET_STATIC_PROPERTY_LV(0x49FC1A1F7B878C3ELL, soapserver);
      break;
    case 65:
      HASH_GET_STATIC_PROPERTY_LV(0x227C70ED5B143841LL, outofboundsexception);
      break;
    case 68:
      HASH_GET_STATIC_PROPERTY_LV(0x4253D8488B734244LL, pdostatement);
      break;
    case 70:
      HASH_GET_STATIC_PROPERTY_LV(0x196F76C9C527B946LL, domnamednodemap);
      HASH_GET_STATIC_PROPERTY_LV(0x66282FC8E4EF4E46LL, badfunctioncallexception);
      break;
    case 73:
      HASH_GET_STATIC_PROPERTY_LV(0x5AA2EE582E0D3849LL, unexpectedvalueexception);
      break;
    case 75:
      HASH_GET_STATIC_PROPERTY_LV(0x4860DC2F9B0E6D4BLL, logicexception);
      break;
    case 77:
      HASH_GET_STATIC_PROPERTY_LV(0x164F490DAC49174DLL, domtext);
      break;
    case 78:
      HASH_GET_STATIC_PROPERTY_LV(0x308D1D59986A3D4ELL, soapheader);
      break;
    case 79:
      HASH_GET_STATIC_PROPERTY_LV(0x5BA243B9FBA7A64FLL, splobjectstorage);
      break;
    case 80:
      HASH_GET_STATIC_PROPERTY_LV(0x52EA111229F87A50LL, normalizer);
      break;
    case 83:
      HASH_GET_STATIC_PROPERTY_LV(0x02239AA5D64B1453LL, domcharacterdata);
      HASH_GET_STATIC_PROPERTY_LV(0x6AF83706F76A9D53LL, rangeexception);
      break;
    case 94:
      HASH_GET_STATIC_PROPERTY_LV(0x7754323897E8A15ELL, directoryiterator);
      break;
    case 97:
      HASH_GET_STATIC_PROPERTY_LV(0x70EBB2CC1FBF9761LL, domdocumenttype);
      break;
    case 98:
      HASH_GET_STATIC_PROPERTY_LV(0x70747A09B3523662LL, domnode);
      break;
    case 101:
      HASH_GET_STATIC_PROPERTY_LV(0x2FF1EF6EBB3DA065LL, xmlwriter);
      break;
    case 104:
      HASH_GET_STATIC_PROPERTY_LV(0x7E07B9C27FE59D68LL, domcomment);
      HASH_GET_STATIC_PROPERTY_LV(0x17A40D895C55D968LL, soapparam);
      break;
    case 106:
      HASH_GET_STATIC_PROPERTY_LV(0x6A5B99D5B1A4566ALL, domexception);
      break;
    case 107:
      HASH_GET_STATIC_PROPERTY_LV(0x3CAE91CFA2AAD16BLL, lengthexception);
      break;
    case 115:
      HASH_GET_STATIC_PROPERTY_LV(0x3D5870E53BF89873LL, arrayiterator);
      HASH_GET_STATIC_PROPERTY_LV(0x0B61E0BFCFA06573LL, reflectionextension);
      break;
    case 116:
      HASH_GET_STATIC_PROPERTY_LV(0x126B0D414E0AFD74LL, concurrentvector);
      break;
    case 117:
      HASH_GET_STATIC_PROPERTY_LV(0x085A4F6FD393D475LL, invalidargumentexception);
      break;
    case 122:
      HASH_GET_STATIC_PROPERTY_LV(0x41A9F7D81254DD7ALL, reflectionobject);
      break;
    case 125:
      HASH_GET_STATIC_PROPERTY_LV(0x7AD161197633B87DLL, domdocumentfragment);
      HASH_GET_STATIC_PROPERTY_LV(0x2E899D2A2572EF7DLL, sqlite3result);
      break;
    case 128:
      HASH_GET_STATIC_PROPERTY_LV(0x59B3EFD1CD987F80LL, domprocessinginstruction);
      break;
    case 130:
      HASH_GET_STATIC_PROPERTY_LV(0x33BD46E935281082LL, reflectionfunctionabstract);
      break;
    case 131:
      HASH_GET_STATIC_PROPERTY_LV(0x24DE53FD7D3E8383LL, datetimezone);
      break;
    case 132:
      HASH_GET_STATIC_PROPERTY_LV(0x70D4A29DE6A7BA84LL, domainexception);
      break;
    case 143:
      HASH_GET_STATIC_PROPERTY_LV(0x34C95AF311506C8FLL, directory);
      break;
    case 144:
      HASH_GET_STATIC_PROPERTY_LV(0x06335FF83CDEA590LL, badmethodcallexception);
      break;
    case 147:
      HASH_GET_STATIC_PROPERTY_LV(0x2E7081C468A05993LL, reflectionparameter);
      break;
    case 148:
      HASH_GET_STATIC_PROPERTY_LV(0x6FFDF8DF15CABE94LL, domcdatasection);
      HASH_GET_STATIC_PROPERTY_LV(0x6576EACCCE24D694LL, __php_incomplete_class);
      HASH_GET_STATIC_PROPERTY_LV(0x47D93E6F80B66A94LL, exception);
      break;
    case 152:
      HASH_GET_STATIC_PROPERTY_LV(0x3CEBA108A1BAB998LL, pear_error);
      break;
    case 167:
      HASH_GET_STATIC_PROPERTY_LV(0x71089C29FE923FA7LL, splfileinfo);
      break;
    case 168:
      HASH_GET_STATIC_PROPERTY_LV(0x7D46DB2E09C6DBA8LL, domxpath);
      break;
    case 169:
      HASH_GET_STATIC_PROPERTY_LV(0x1D35C3EFD00E11A9LL, sqlite3);
      break;
    case 173:
      HASH_GET_STATIC_PROPERTY_LV(0x0A34015F67C804ADLL, pdo);
      break;
    case 175:
      HASH_GET_STATIC_PROPERTY_LV(0x2E650138BA043AAFLL, domdocument);
      break;
    case 176:
      HASH_GET_STATIC_PROPERTY_LV(0x43BBC8F6F28E44B0LL, reflectionmethod);
      break;
    case 177:
      HASH_GET_STATIC_PROPERTY_LV(0x6DD772FA3B20B8B1LL, domnodelist);
      break;
    case 189:
      HASH_GET_STATIC_PROPERTY_LV(0x5D8785ACD19F77BDLL, pdoexception);
      break;
    case 195:
      HASH_GET_STATIC_PROPERTY_LV(0x40B3C44077F5DDC3LL, domelement);
      break;
    case 200:
      HASH_GET_STATIC_PROPERTY_LV(0x2E363D51549781C8LL, appenditerator);
      break;
    case 203:
      HASH_GET_STATIC_PROPERTY_LV(0x253AC17234FC8CCBLL, libxmlerror);
      break;
    case 210:
      HASH_GET_STATIC_PROPERTY_LV(0x52E5CC58B841AED2LL, sqlite3stmt);
      HASH_GET_STATIC_PROPERTY_LV(0x297ECCC7A259EDD2LL, splfileobject);
      break;
    case 212:
      HASH_GET_STATIC_PROPERTY_LV(0x5E623FEAF7B068D4LL, underflowexception);
      break;
    case 216:
      HASH_GET_STATIC_PROPERTY_LV(0x464D3427431A6ED8LL, recursivedirectoryiterator);
      break;
    case 217:
      HASH_GET_STATIC_PROPERTY_LV(0x0E4CCE95F6A727D9LL, overflowexception);
      break;
    case 218:
      HASH_GET_STATIC_PROPERTY_LV(0x7A52EBE538182BDALL, soapclient);
      break;
    case 220:
      HASH_GET_STATIC_PROPERTY_LV(0x1078CB3118A8B3DCLL, runtimeexception);
      break;
    case 228:
      HASH_GET_STATIC_PROPERTY_LV(0x75AA2571BDB659E4LL, reflectionproperty);
      break;
    case 244:
      HASH_GET_STATIC_PROPERTY_LV(0x297174231D4912F4LL, domattr);
      break;
    case 246:
      HASH_GET_STATIC_PROPERTY_LV(0x1D1BA0A732290FF6LL, concurrenthash);
      break;
    case 247:
      HASH_GET_STATIC_PROPERTY_LV(0x3D69936178BA13F7LL, stdclass);
      break;
    case 252:
      HASH_GET_STATIC_PROPERTY_LV(0x622D4DF07E2A01FCLL, outofrangeexception);
      break;
    case 253:
      HASH_GET_STATIC_PROPERTY_LV(0x74419B70A46387FDLL, domimplementation);
      break;
    case 255:
      HASH_GET_STATIC_PROPERTY_LV(0x624835B2D74B86FFLL, domentity);
      break;
    default:
      break;
  }
  return NULL;
}
Variant get_builtin_class_constant(const char *s, const char *constant, bool fatal /* = true */) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string_i(s);
  switch (hash & 255) {
    case 9:
      HASH_GET_CLASS_CONSTANT(0x21EF70351574EC09LL, reflectionfunction);
      break;
    case 11:
      HASH_GET_CLASS_CONSTANT(0x4365BE9E5A85E60BLL, domnotation);
      HASH_GET_CLASS_CONSTANT(0x69EDCA1CC29CFE0BLL, errorexception);
      break;
    case 19:
      HASH_GET_CLASS_CONSTANT(0x6A76B9AABB7CC713LL, simplexmlelement);
      break;
    case 21:
      HASH_GET_CLASS_CONSTANT(0x32E5C767255D2515LL, soapfault);
      break;
    case 26:
      HASH_GET_CLASS_CONSTANT(0x5CBA5B52C68B501ALL, domentityreference);
      break;
    case 29:
      HASH_GET_CLASS_CONSTANT(0x35A44A5E6AE2E71DLL, reflectionclass);
      break;
    case 30:
      HASH_GET_CLASS_CONSTANT(0x3DB8FB455A602A1ELL, datetime);
      break;
    case 43:
      HASH_GET_CLASS_CONSTANT(0x7E66D362EAB5BF2BLL, simplexmlelementiterator);
      break;
    case 49:
      HASH_GET_CLASS_CONSTANT(0x7A394042E7488231LL, filteriterator);
      break;
    case 50:
      HASH_GET_CLASS_CONSTANT(0x365899865E2EAA32LL, recursiveiteratoriterator);
      break;
    case 53:
      HASH_GET_CLASS_CONSTANT(0x7909270014376235LL, soapvar);
      break;
    case 55:
      HASH_GET_CLASS_CONSTANT(0x7FF7A8442616EF37LL, domnodeiterator);
      break;
    case 56:
      HASH_GET_CLASS_CONSTANT(0x672AD818DDE95538LL, reflectionexception);
      break;
    case 62:
      HASH_GET_CLASS_CONSTANT(0x49FC1A1F7B878C3ELL, soapserver);
      break;
    case 65:
      HASH_GET_CLASS_CONSTANT(0x227C70ED5B143841LL, outofboundsexception);
      break;
    case 68:
      HASH_GET_CLASS_CONSTANT(0x4253D8488B734244LL, pdostatement);
      break;
    case 70:
      HASH_GET_CLASS_CONSTANT(0x196F76C9C527B946LL, domnamednodemap);
      HASH_GET_CLASS_CONSTANT(0x66282FC8E4EF4E46LL, badfunctioncallexception);
      break;
    case 73:
      HASH_GET_CLASS_CONSTANT(0x5AA2EE582E0D3849LL, unexpectedvalueexception);
      break;
    case 75:
      HASH_GET_CLASS_CONSTANT(0x4860DC2F9B0E6D4BLL, logicexception);
      break;
    case 77:
      HASH_GET_CLASS_CONSTANT(0x164F490DAC49174DLL, domtext);
      break;
    case 78:
      HASH_GET_CLASS_CONSTANT(0x308D1D59986A3D4ELL, soapheader);
      break;
    case 79:
      HASH_GET_CLASS_CONSTANT(0x5BA243B9FBA7A64FLL, splobjectstorage);
      break;
    case 80:
      HASH_GET_CLASS_CONSTANT(0x52EA111229F87A50LL, normalizer);
      break;
    case 83:
      HASH_GET_CLASS_CONSTANT(0x02239AA5D64B1453LL, domcharacterdata);
      HASH_GET_CLASS_CONSTANT(0x6AF83706F76A9D53LL, rangeexception);
      break;
    case 94:
      HASH_GET_CLASS_CONSTANT(0x7754323897E8A15ELL, directoryiterator);
      break;
    case 97:
      HASH_GET_CLASS_CONSTANT(0x70EBB2CC1FBF9761LL, domdocumenttype);
      break;
    case 98:
      HASH_GET_CLASS_CONSTANT(0x70747A09B3523662LL, domnode);
      break;
    case 101:
      HASH_GET_CLASS_CONSTANT(0x2FF1EF6EBB3DA065LL, xmlwriter);
      break;
    case 104:
      HASH_GET_CLASS_CONSTANT(0x7E07B9C27FE59D68LL, domcomment);
      HASH_GET_CLASS_CONSTANT(0x17A40D895C55D968LL, soapparam);
      break;
    case 106:
      HASH_GET_CLASS_CONSTANT(0x6A5B99D5B1A4566ALL, domexception);
      break;
    case 107:
      HASH_GET_CLASS_CONSTANT(0x3CAE91CFA2AAD16BLL, lengthexception);
      break;
    case 115:
      HASH_GET_CLASS_CONSTANT(0x3D5870E53BF89873LL, arrayiterator);
      HASH_GET_CLASS_CONSTANT(0x0B61E0BFCFA06573LL, reflectionextension);
      break;
    case 116:
      HASH_GET_CLASS_CONSTANT(0x126B0D414E0AFD74LL, concurrentvector);
      break;
    case 117:
      HASH_GET_CLASS_CONSTANT(0x085A4F6FD393D475LL, invalidargumentexception);
      break;
    case 122:
      HASH_GET_CLASS_CONSTANT(0x41A9F7D81254DD7ALL, reflectionobject);
      break;
    case 125:
      HASH_GET_CLASS_CONSTANT(0x7AD161197633B87DLL, domdocumentfragment);
      HASH_GET_CLASS_CONSTANT(0x2E899D2A2572EF7DLL, sqlite3result);
      break;
    case 128:
      HASH_GET_CLASS_CONSTANT(0x59B3EFD1CD987F80LL, domprocessinginstruction);
      break;
    case 130:
      HASH_GET_CLASS_CONSTANT(0x33BD46E935281082LL, reflectionfunctionabstract);
      break;
    case 131:
      HASH_GET_CLASS_CONSTANT(0x24DE53FD7D3E8383LL, datetimezone);
      break;
    case 132:
      HASH_GET_CLASS_CONSTANT(0x70D4A29DE6A7BA84LL, domainexception);
      break;
    case 143:
      HASH_GET_CLASS_CONSTANT(0x34C95AF311506C8FLL, directory);
      break;
    case 144:
      HASH_GET_CLASS_CONSTANT(0x06335FF83CDEA590LL, badmethodcallexception);
      break;
    case 147:
      HASH_GET_CLASS_CONSTANT(0x2E7081C468A05993LL, reflectionparameter);
      break;
    case 148:
      HASH_GET_CLASS_CONSTANT(0x6FFDF8DF15CABE94LL, domcdatasection);
      HASH_GET_CLASS_CONSTANT(0x6576EACCCE24D694LL, __php_incomplete_class);
      HASH_GET_CLASS_CONSTANT(0x47D93E6F80B66A94LL, exception);
      break;
    case 152:
      HASH_GET_CLASS_CONSTANT(0x3CEBA108A1BAB998LL, pear_error);
      break;
    case 167:
      HASH_GET_CLASS_CONSTANT(0x71089C29FE923FA7LL, splfileinfo);
      break;
    case 168:
      HASH_GET_CLASS_CONSTANT(0x7D46DB2E09C6DBA8LL, domxpath);
      break;
    case 169:
      HASH_GET_CLASS_CONSTANT(0x1D35C3EFD00E11A9LL, sqlite3);
      break;
    case 173:
      HASH_GET_CLASS_CONSTANT(0x0A34015F67C804ADLL, pdo);
      break;
    case 175:
      HASH_GET_CLASS_CONSTANT(0x2E650138BA043AAFLL, domdocument);
      break;
    case 176:
      HASH_GET_CLASS_CONSTANT(0x43BBC8F6F28E44B0LL, reflectionmethod);
      break;
    case 177:
      HASH_GET_CLASS_CONSTANT(0x6DD772FA3B20B8B1LL, domnodelist);
      break;
    case 189:
      HASH_GET_CLASS_CONSTANT(0x5D8785ACD19F77BDLL, pdoexception);
      break;
    case 195:
      HASH_GET_CLASS_CONSTANT(0x40B3C44077F5DDC3LL, domelement);
      break;
    case 200:
      HASH_GET_CLASS_CONSTANT(0x2E363D51549781C8LL, appenditerator);
      break;
    case 203:
      HASH_GET_CLASS_CONSTANT(0x253AC17234FC8CCBLL, libxmlerror);
      break;
    case 210:
      HASH_GET_CLASS_CONSTANT(0x52E5CC58B841AED2LL, sqlite3stmt);
      HASH_GET_CLASS_CONSTANT(0x297ECCC7A259EDD2LL, splfileobject);
      break;
    case 212:
      HASH_GET_CLASS_CONSTANT(0x5E623FEAF7B068D4LL, underflowexception);
      break;
    case 216:
      HASH_GET_CLASS_CONSTANT(0x464D3427431A6ED8LL, recursivedirectoryiterator);
      break;
    case 217:
      HASH_GET_CLASS_CONSTANT(0x0E4CCE95F6A727D9LL, overflowexception);
      break;
    case 218:
      HASH_GET_CLASS_CONSTANT(0x7A52EBE538182BDALL, soapclient);
      break;
    case 220:
      HASH_GET_CLASS_CONSTANT(0x1078CB3118A8B3DCLL, runtimeexception);
      break;
    case 228:
      HASH_GET_CLASS_CONSTANT(0x75AA2571BDB659E4LL, reflectionproperty);
      break;
    case 244:
      HASH_GET_CLASS_CONSTANT(0x297174231D4912F4LL, domattr);
      break;
    case 246:
      HASH_GET_CLASS_CONSTANT(0x1D1BA0A732290FF6LL, concurrenthash);
      break;
    case 247:
      HASH_GET_CLASS_CONSTANT(0x3D69936178BA13F7LL, stdclass);
      break;
    case 252:
      HASH_GET_CLASS_CONSTANT(0x622D4DF07E2A01FCLL, outofrangeexception);
      break;
    case 253:
      HASH_GET_CLASS_CONSTANT(0x74419B70A46387FDLL, domimplementation);
      break;
    case 255:
      HASH_GET_CLASS_CONSTANT(0x624835B2D74B86FFLL, domentity);
      break;
    default:
      break;
  }
  if (fatal) {
    raise_error("Couldn't find constant %s::%s", s, constant);
  } else {
    raise_warning("Couldn't find constant %s::%s", s, constant);
  }
  return null;
}

///////////////////////////////////////////////////////////////////////////////
}
